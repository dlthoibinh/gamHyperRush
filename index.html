<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,maximum-scale=1">
  <meta name="theme-color" content="#0ea5e9">
  <meta name="robots" content="noindex,nofollow">
  <title>HyperRush — Freeze Edition</title>
  <link rel="manifest" href="manifest.json">
  <style>
    :root{ --brand:#0ea5e9; --bg:#0b1220; --card:#0f172a; --text:#e5f0ff; --muted:#93a4c3; --ok:#16a34a; --bad:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0b1326 60%,#0b1220);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;touch-action:manipulation;-webkit-tap-highlight-color:transparent;outline:0}
    #wrap{max-width:480px;margin:0 auto;position:relative;height:100vh;overflow:hidden}
    #game{display:block;width:100%;height:100%;background:radial-gradient(ellipse at 50% -10%,rgba(14,165,233,.25),transparent 55%), linear-gradient(180deg, #0a0f1c, #0b1220)}
    .ui{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
    .card{background:rgba(15,23,42,.82);backdrop-filter:blur(8px);border:1px solid rgba(148,163,184,.15);border-radius:16px;padding:18px 16px;max-width:420px;width:100%;box-shadow:0 20px 50px rgba(14,165,233,.08)}
    h1{font-size:22px;margin:0 0 4px;letter-spacing:.2px}
    p{margin:4px 0 10px;color:var(--muted);font-size:14px}
    .row{display:flex;gap:10px;margin-top:10px}
    button{flex:1;border:0;border-radius:12px;background:var(--brand);color:#fff;font-weight:700;padding:12px 14px;font-size:16px;box-shadow:0 10px 30px rgba(14,165,233,.25);cursor:pointer}
    button:active{transform:translateY(1px)}
    input[type="text"]{flex:1;background:#0b1220;border:1px solid rgba(148,163,184,.2);border-radius:12px;color:#fff;padding:10px 12px;outline:none}
    .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;font-weight:700;text-shadow:0 2px 10px rgba(0,0,0,.4);z-index:40}
    .pill{background:rgba(2,6,23,.55);border:1px solid rgba(148,163,184,.15);padding:8px 12px;border-radius:999px}
    .hint{font-size:12px;color:var(--muted)}
    .small{font-size:12px}
    .center{text-align:center}
    .mt8{margin-top:8px}

    /* Gauge – cố định */
    #gauge{position:absolute;right:8px;top:46px;width:64px;height:64px;border-radius:999px;background:rgba(2,6,23,.45);border:1px solid rgba(148,163,184,.15);display:flex;align-items:center;justify-content:center;z-index:50;pointer-events:none}
    #gcv{width:56px;height:56px;display:block}

    #toast{position:absolute;left:50%;top:58px;transform:translateX(-50%);padding:6px 10px;background:rgba(250,250,250,.12);border:1px solid rgba(255,255,255,.2);border-radius:999px;font-size:12px;opacity:0;transition:opacity .18s, transform .18s;z-index:45}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}

    [hidden]{display:none !important;}
    .ui[hidden]{display:none !important;}

    #game{ touch-action:none; }
    html,body,#wrap{ overscroll-behavior:none; }

    .touch-ctrl{
      position:absolute;left:0;right:0;bottom:18px;
      display:flex;justify-content:space-between;padding:0 18px;pointer-events:none;z-index:35
    }
    .touch-ctrl button{
      width:64px;height:64px;border-radius:999px;border:0;
      background:rgba(2,6,23,.35);color:#fff;font-size:22px;
      border:1px solid rgba(148,163,184,.18);box-shadow:0 10px 20px rgba(0,0,0,.2);
      pointer-events:auto
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640" aria-label="HyperRush Freeze"></canvas>

    <div id="uiStart" class="ui" role="dialog" aria-modal="true">
      <div class="card">
        <h1>HyperRush — Freeze</h1>
        <p>Giữ chạm để <b>Freeze</b>. Vuốt ngang để <b>kéo</b> nhân vật – không nhảy bậc.</p>
        <div class="row">
          <input id="name" type="text" maxlength="16" placeholder="Tên hiển thị (tuỳ chọn)">
          <button id="btnPlay">Chơi ngay</button>
        </div>
        <p class="hint">PC: A/D hoặc ← → (nhảy 1 làn); giữ Space để freeze.</p>
        <div class="small">Bản đồ mỗi ngày thay đổi (daily seed). Thử vượt 2.500!</div>
      </div>
    </div>

    <div id="uiHUD" class="hud" hidden>
      <div class="pill">Điểm: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
    </div>

    <div id="uiOver" class="ui" hidden role="dialog" aria-modal="true">
      <div class="card center">
        <h1>Thua rồi!</h1>
        <p>Điểm: <b id="finalScore">0</b> • Best: <b id="best2">0</b></p>
        <div class="row">
          <button id="btnRetry">Chơi lại</button>
          <button id="btnShare">Chia sẻ</button>
        </div>
        <div id="overMsg" class="hint mt8"></div>
      </div>
    </div>

    <div id="gauge" aria-label="Freeze energy">
      <canvas id="gcv" width="96" height="96"></canvas>
    </div>
    <div id="toast">NEAR-MISS +6%</div>

    <div id="touchCtrl" class="touch-ctrl" hidden>
      <button id="btnL">◀</button>
      <button id="btnR">▶</button>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /* =============== Config =============== */
  const CONFIG = {
    API_URL: 'https://script.google.com/macros/s/AKfycbznfw8rrffCKv0OObRRc8j6YHKir6dEwpLrG4eNn-Azc3xvg4_UrI3fbUoBRv6Dq-e1DQ/exec',
    AUDIO: { enabled: true, volume: 0.32 },
    PERF:  { dprMax: 1.5, maxEntities: 120, maxParticles: 180 },
    GAME: {
      lanes: 3,
      baseSpeed: 135,
      accel: 0.06,
      spawnEvery: 740,
      spawnAccel: 0.986,
      orbChance: 0.22,
      freezeRate: 0.28,
      regenPassive: 0.003,
      regenNear: 6,
      regenOrb: 10,
      freezeSlow: 0.25,
      laneSmoothingMs: 95,   // <<< mượt theo tay (analog)
      minGapObPx: 148,
      minGapOrbPx: 118,
      maxSpawnAttempts: 3,
      surgeEvery: 300,
      surgeMs: 3000
    }
  };
  const LOW = (navigator.hardwareConcurrency && navigator.hardwareConcurrency<=4);
  if (LOW){ CONFIG.PERF.dprMax=1.2; CONFIG.PERF.maxParticles=120; }

  /* =============== Utils =============== */
  const $ = sel => document.querySelector(sel);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();
  function vibrate(p){try{navigator.vibrate && navigator.vibrate(p);}catch(_){}} 

  function getDeviceId(){
    const k='hrfz_device_id'; let id=localStorage.getItem(k);
    if(!id){ id=crypto.getRandomValues(new Uint32Array(4)).join('-'); localStorage.setItem(k,id); }
    return id;
  }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

  const BASE_W = 360, BASE_H = 640, MARGIN=40;
  function fitCanvas(canvas){
    const parent=canvas.parentElement; const ratio=BASE_W/BASE_H;
    const w=parent.clientWidth, h=parent.clientHeight; let cw=w, ch=w/ratio;
    if (ch>h) { ch=h; cw=h*ratio; }
    canvas.style.width=cw+'px'; canvas.style.height=ch+'px';
    const dpr = Math.min(CONFIG.PERF.dprMax, window.devicePixelRatio||1);
    canvas.width = Math.round(BASE_W*dpr);
    canvas.height = Math.round(BASE_H*dpr);
    const ctx = canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function dailySeed(){
    const d = new Date(); const s = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())>>>0;
    return s ^ (getDeviceId().split('-')[0]>>>0);
  }

  /* =============== WebAudio SFX =============== */
  const AudioKit = (function(){
    let ctx, master;
    function ensure(){
      if (!CONFIG.AUDIO.enabled) return null;
      if (!ctx){ ctx = new (window.AudioContext||window.webkitAudioContext)(); master = ctx.createGain(); master.gain.value = CONFIG.AUDIO.volume; master.connect(ctx.destination); }
      return ctx;
    }
    function unlock(){ const c=ensure(); if (!c) return; if (c.state==='suspended') c.resume().catch(()=>{}); }
    function tone(opt){
      const c=ensure(); if(!c) return;
      const o=c.createOscillator(), g=c.createGain();
      o.type = opt.type||'sine'; o.frequency.value = opt.freq||440; if (opt.detune) o.detune.value = opt.detune;
      g.gain.value = 0; o.connect(g); g.connect(master);
      const t=c.currentTime, a=opt.attack||0.005, d=opt.decay||0.12, s=opt.sustain||0.0001, r=opt.release||0.08, v=opt.gain||0.4;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(s,t+a+d); g.gain.linearRampToValueAtTime(0,t+a+d+r);
      o.start(t); o.stop(t+a+d+r+0.01);
    }
    function noise(opt){
      const c=ensure(); if(!c) return;
      const b=c.createBuffer(1, c.sampleRate*0.18, c.sampleRate); const data=b.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
      const src=c.createBufferSource(); src.buffer=b; const g=c.createGain(); g.gain.value=0; src.connect(g); g.connect(master);
      const t=c.currentTime, a=opt.attack||0.005, r=opt.release||0.14, v=opt.gain||0.45;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(0,t+a+r);
      src.start(t); src.stop(t+a+r+0.01);
    }
    function sfx(name){
      switch(name){
        case 'move': tone({type:'square',freq:640,gain:0.18,decay:0.06,release:0.06}); break;
        case 'near': tone({type:'triangle',freq:880,gain:0.22,decay:0.04}); break;
        case 'orb':  tone({type:'sine',freq:520,gain:0.26,decay:0.05}); tone({type:'sine',freq:780,gain:0.20,decay:0.07}); break;
        case 'freeze_on': tone({type:'sawtooth',freq:300,gain:0.18,decay:0.08}); break;
        case 'hit':  noise({gain:0.6}); tone({type:'square',freq:140,gain:0.25,decay:0.09,release:0.2}); break;
        case 'taunt': tone({type:'triangle',freq:480,gain:0.16,decay:0.12}); break;
      }
    }
    return {unlock,sfx};
  })();

  /* =============== Backend (optional) =============== */
  async function postScore(name, score) {
    if (!CONFIG.API_URL) return;
    try {
      const body = JSON.stringify({
        deviceId: getDeviceId(),
        name: String(name||'').slice(0,16),
        score: Math.max(0, Math.floor(score)),
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
        ua: navigator.userAgent
      });
      await fetch(CONFIG.API_URL, { method:'POST', mode:'cors', headers:{'Content-Type':'text/plain'}, body,
        signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined }).catch(()=>{});
    } catch (_){}
  }

  /* =============== Game State =============== */
  const canvas = $('#game'); const ctx = canvas.getContext('2d'); fitCanvas(canvas); window.addEventListener('resize', ()=>fitCanvas(canvas));
  const gcv = $('#gcv'); const gctx = gcv.getContext('2d');

  let W=BASE_W, H=BASE_H;
  const state = {
    running:false, over:false,
    name:'', score:0, best:Number(localStorage.getItem('hrfz_best')||0),
    rng: mulberry32(dailySeed()),
    speed: CONFIG.GAME.baseSpeed,
    lastSpawn: 0, spawnEvery: CONFIG.GAME.spawnEvery,
    lane: 1.0,              // vị trí hiện tại (liên tục)
    desiredLane: 1.0,       // mục tiêu (kéo theo tay)
    playerY: H-120,
    entities: [],
    energy: 60,
    holding:false,
    lastNearT: 0,
    shake: 0,
    particles: [],
    surgeMs: 0, nextSurge: CONFIG.GAME.surgeEvery,
    dragging:false, dragStartX:0, dragStartLane:1.0, hasDragged:false
  };

  /* =============== Particles =============== */
  function spawnParticles(x,y,color,count=12,spd=1){
    const allow = Math.max(0, CONFIG.PERF.maxParticles - state.particles.length);
    count = Math.min(count, allow);
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      state.particles.push({ x,y, vx: Math.cos(a)*(1.2+Math.random()*2)*spd, vy: Math.sin(a)*(1.2+Math.random()*2)*spd,
        life: 420+Math.random()*260, age:0, color });
    }
  }

  /* =============== Input =============== */
  function stepLane(dir){ // dùng cho phím & tap
    const next = clamp(Math.round(state.desiredLane) + Math.sign(dir), 0, CONFIG.GAME.lanes-1);
    if (next!==Math.round(state.desiredLane)){ state.desiredLane = next; AudioKit.sfx('move'); }
  }

  // Phím
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowleft'||k==='a') stepLane(-1);
    if (k==='arrowright'||k==='d') stepLane(1);
    if (k===' ') { state.holding = true; AudioKit.sfx('freeze_on'); }
  }, {passive:true});
  window.addEventListener('keyup', (e)=>{ if (e.key===' ') state.holding=false; }, {passive:true});

  // Pointer – analog drag
  canvas.addEventListener('pointerdown', (e)=>{
    if (state.dragging) return;
    state.dragging=true; state.dragStartX=e.clientX; state.dragStartLane=state.desiredLane; state.hasDragged=false;
    canvas.setPointerCapture(e.pointerId); state.holding=true; AudioKit.unlock(); AudioKit.sfx('freeze_on');
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if (!state.dragging) return;
    const dx = e.clientX - state.dragStartX;
    const laneW = (W - MARGIN*2)/CONFIG.GAME.lanes;
    const cont = state.dragStartLane + dx / laneW;        // liên tục theo tay
    state.desiredLane = clamp(cont, 0, CONFIG.GAME.lanes-1);
    if (Math.abs(dx)>6) state.hasDragged=true;
    e.preventDefault();
  }, {passive:false});

  function endPointer(e){
    if (!state.dragging) return;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    // Nếu không kéo, xem như tap trái/phải
    if (!state.hasDragged){
      const r=canvas.getBoundingClientRect();
      stepLane(e.clientX < r.left + r.width/2 ? -1 : 1);
    }
    state.dragging=false; state.holding=false;
    e.preventDefault();
  }
  canvas.addEventListener('pointerup', endPointer, {passive:false});
  canvas.addEventListener('pointercancel', endPointer, {passive:false});
  document.addEventListener('visibilitychange', ()=>{ if (document.hidden) state.holding=false; }, {passive:true});

  /* =============== Loop =============== */
  function update(dt) {
    const timeScale = state.holding && state.energy>0 ? CONFIG.GAME.freezeSlow : 1;
    const dtEff = dt * timeScale;

    // energy
    state.energy = state.holding && state.energy>0
      ? Math.max(0, state.energy - CONFIG.GAME.freezeRate * (dt/10))
      : Math.min(100, state.energy + CONFIG.GAME.regenPassive * (dt/10));

    // difficulty & score
    state.speed += CONFIG.GAME.accel * dtEff/16.6;
    state.spawnEvery *= Math.pow(CONFIG.GAME.spawnAccel, dtEff/16.6);
    state.score += dtEff * 0.06 * ( (state.lastNearT && (now()-state.lastNearT<1200)) ? 1.15 : 1 );
    $('#score').textContent = String(Math.floor(state.score));

    // lane smoothing (theo tay — không nhảy)
    const t = Math.min(1, dtEff / CONFIG.GAME.laneSmoothingMs);
    state.lane += (state.desiredLane - state.lane) * (1 - Math.pow(1 - t, 3)); // easeOutCubic

    // Surge
    if (state.score >= state.nextSurge){ state.surgeMs = CONFIG.GAME.surgeMs; state.nextSurge += CONFIG.GAME.surgeEvery; toast('Cửa hẹp 3s!'); AudioKit.sfx('taunt'); }
    if (state.surgeMs>0) state.surgeMs = Math.max(0, state.surgeMs - dt);

    // Spawn
    state.lastSpawn += dtEff;
    while (state.lastSpawn >= state.spawnEvery) {
      state.lastSpawn -= state.spawnEvery;
      const times = 1 + (state.surgeMs>0 ? 1 : 0);
      for (let k=0;k<times;k++) trySpawn();
    }

    // Move + collisions
    const px = laneX(state.lane), py = state.playerY;
    for (let i=state.entities.length-1;i>=0;i--) {
      const e = state.entities[i];
      e.y += state.speed * dtEff/1000;

      if (e.type==='ob') {
        const dx = Math.abs(laneX(e.lane)-px), dy = Math.abs(e.y - py);
        if (dx < 38 && dy>36 && dy<86 && now()-state.lastNearT>240) {
          state.energy = Math.min(100, state.energy + CONFIG.GAME.regenNear);
          toast('NEAR-MISS +' + CONFIG.GAME.regenNear + '%'); state.lastNearT = now();
          AudioKit.sfx('near'); vibrate(10);
        }
      }

      if (Math.abs(laneX(e.lane)-px) < 36 && Math.abs(e.y - py) < 36) {
        if (e.type==='orb') {
          state.score += 50; state.energy = Math.min(100, state.energy + CONFIG.GAME.regenOrb);
          state.entities.splice(i,1); flash(120); spawnParticles(px,py,'#38bdf8',12,1.1); AudioKit.sfx('orb'); vibrate(12);
        } else {
          if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
          boom(); spawnParticles(px,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
          return gameOver();
        }
      }
      if (e.y > H+50) state.entities.splice(i,1);
    }

    // particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p=state.particles[i]; p.age += dtEff; if (p.age>p.life){ state.particles.splice(i,1); continue; }
      p.x += p.vx * dtEff/16.6; p.y += p.vy * dtEff/16.6; p.vy += 0.002*dtEff;
    }
    state.shake *= 0.92;
  }

  function trySpawn(){
    if (state.entities.length >= CONFIG.PERF.maxEntities) return;
    const type = (state.rng() < CONFIG.GAME.orbChance) ? 'orb' : 'ob';
    let lane = Math.floor(state.rng()*CONFIG.GAME.lanes), tries=0;
    do {
      let lastY = null;
      for (let i = state.entities.length - 1; i >= 0; i--) { const e = state.entities[i]; if (e.lane === lane) { lastY = e.y; break; } }
      const need = (type === 'ob' ? CONFIG.GAME.minGapObPx : CONFIG.GAME.minGapOrbPx);
      if (lastY === null || (lastY + 40) >= need) { state.entities.push({ type, lane, y: -40 }); return; }
      lane = (lane + 1) % CONFIG.GAME.lanes;
    } while (++tries < CONFIG.GAME.maxSpawnAttempts);
  }

  /* =============== Render =============== */
  function laneX(lane){
    const roadW=W - MARGIN*2; const laneW = roadW/CONFIG.GAME.lanes;
    return Math.round(MARGIN + laneW*(0.5 + lane));
  }
  function drawRoad(){
    const roadW=W - MARGIN*2;
    ctx.save();
    ctx.strokeStyle = 'rgba(148,163,184,0.15)'; ctx.lineWidth=2;
    for (let i=1;i<CONFIG.GAME.lanes;i++){ const x=MARGIN+roadW/CONFIG.GAME.lanes*i; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    const mult = state.surgeMs>0 ? 1.7 : 1;
    const offset = ((performance.now() * (state.holding && state.energy>0 ? 0.25 : 1)*mult)/20) % 40;
    ctx.strokeStyle='rgba(14,165,233,0.25)'; ctx.lineWidth=4;
    for (let y=-offset; y<H; y+=40){ ctx.beginPath(); ctx.moveTo(MARGIN+8,y); ctx.lineTo(W-MARGIN-8,y); ctx.stroke(); }
    ctx.restore();
  }
  function drawPlayer(x,y){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(0,18,20,8,0,0,Math.PI*2); ctx.fill();
    const grd = ctx.createLinearGradient(-16,-16,16,16);
    grd.addColorStop(0,'#22d3ee'); grd.addColorStop(1,'#0ea5e9');
    ctx.fillStyle=grd; roundRect(-16,-16,32,32,8,true,false);
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(0,-8); ctx.lineTo(8,0); ctx.lineTo(0,8); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
  function drawObstacle(x,y){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle = 'rgba(0,0,0,.28)'; ctx.beginPath(); ctx.ellipse(0,16,16,6,0,0,Math.PI*2); ctx.fill();
    const grd = ctx.createLinearGradient(0,-18,0,18);
    grd.addColorStop(0,'#c64040');  grd.addColorStop(1,'#9f2c2c');
    ctx.fillStyle = grd; roundRect(-18,-18,36,36,8,true,false);
    ctx.strokeStyle='rgba(0,0,0,.40)'; ctx.lineWidth=1.5; roundRect(-18,-18,36,36,8,false,true);
    ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-14,-12); ctx.lineTo(14,-12); ctx.stroke();
    ctx.restore();
  }
  function drawOrb(x,y){
    ctx.save(); ctx.translate(x,y);
    const r=10+Math.sin(performance.now()/120 + x)*2;
    const g=ctx.createRadialGradient(0,0,2,0,0,r);
    g.addColorStop(0,'rgba(255,255,255,0.85)');
    g.addColorStop(1,'rgba(56,189,248,0.9)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }

  /* =============== FX / Gauge / Toast =============== */
  let flashT=0, boomT=0;
  function flash(ms){ flashT=now()+ms; }
  function boom(){ boomT=now()+250; state.shake = 10; }
  const origFill = ctx.fillStyle;
  const _draw = draw; draw = function(){ _draw(); postFX(); };
  function postFX(){
    const t=now();
    if (flashT>t){ ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(0,0,W,H); ctx.fillStyle=origFill; }
    if (boomT>t){ const k=(boomT-t)/250; ctx.save(); ctx.translate(W/2,H/2); ctx.rotate((1-k)*0.4); ctx.scale(1+(1-k)*0.05,1+(1-k)*0.05); ctx.restore(); }
  }
  function drawGauge(){
    const pct = clamp(state.energy,0,100)/100;
    const c=gctx; const w=gcv.width, h=gcv.height; c.clearRect(0,0,w,h);
    c.save(); c.translate(w/2,h/2);
    c.strokeStyle='rgba(148,163,184,.22)'; c.lineWidth=10; c.beginPath(); c.arc(0,0,26,0,Math.PI*2); c.stroke();
    const end = -Math.PI/2 + pct*2*Math.PI;
    const grad = c.createLinearGradient(-30,-30,30,30); grad.addColorStop(0,'#22d3ee'); grad.addColorStop(1,'#0ea5e9');
    c.strokeStyle = grad; c.lineWidth=10; c.lineCap='round'; c.beginPath(); c.arc(0,0,26,-Math.PI/2, end); c.stroke();
    c.fillStyle='rgba(255,255,255,.9)'; c.beginPath(); c.moveTo(-5,0); c.lineTo(0,-5); c.lineTo(5,0); c.lineTo(0,5); c.closePath(); c.fill();
    c.restore();
  }
  function toast(txt){
    const el=$('#toast'); el.textContent=txt; el.classList.add('show');
    clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'),760);
  }

  /* =============== UI =============== */
  function gameOver(){
    state.running=false; state.over=true;
    $('#uiHUD').hidden=true; $('#uiOver').hidden=false; $('#touchCtrl').hidden=true;
    $('#finalScore').textContent = Math.floor(state.score);
    $('#best2').textContent = state.best;
    const s = Math.floor(state.score);
    const next = Math.ceil(s/100)*100; const diff = next - s;
    $('#overMsg').textContent = (s>0 && diff>0 && diff<=12) ? `Thiếu ${diff} điểm nữa là chạm ${next}!`
      : (s>state.best ? 'Kỷ lục mới! Lần sau vượt 2.500 nhé.' : 'Gần thôi, thêm chút “sượt nhẹ” là qua!');
    postScore(state.name, state.score);
  }
  function resetGame(){
    state.running=true; state.over=false;
    state.score=0; state.speed=CONFIG.GAME.baseSpeed;
    state.lastSpawn=0; state.spawnEvery=CONFIG.GAME.spawnEvery;
    state.lane=1.0; state.desiredLane=1.0;
    state.entities.length=0; state.particles.length=0;
    state.energy = 60; state.shake = 0; state.surgeMs=0; state.nextSurge=CONFIG.GAME.surgeEvery;
    $('#uiHUD').hidden=false; $('#uiStart').hidden=true; $('#uiOver').hidden=true; $('#touchCtrl').hidden=false;
    $('#score').textContent='0'; $('#best').textContent=String(state.best);
  }
  function startFromUI(){ state.name = $('#name').value.trim().slice(0,16); resetGame(); loop(); }

  $('#btnPlay').addEventListener('click', startFromUI);
  $('#btnRetry').addEventListener('click', startFromUI);
  $('#btnShare').addEventListener('click', async ()=>{
    const text=`Tôi đạt ${Math.floor(state.score)} điểm ở #HyperRushFreeze — bạn dám vượt không?`;
    try{ if (navigator.share) await navigator.share({title:'HyperRush Freeze', text, url:location.href});
      else { await navigator.clipboard.writeText(`${text}\n${location.href}`); alert('Đã copy liên kết!'); } }catch(_){}
  });
  $('#btnL').addEventListener('click', ()=>stepLane(-1));
  $('#btnR').addEventListener('click', ()=>stepLane(1));
  $('#best').textContent = String(state.best);

  const ps = new URLSearchParams(location.search);
  if (ps.get('autoplay')==='1'){ setTimeout(startFromUI, 300); }

  if ('serviceWorker' in navigator) { window.addEventListener('load', ()=>navigator.serviceWorker.register('./sw.js').catch(()=>{})); }
  new ResizeObserver(()=>fitCanvas(canvas)).observe($('#wrap'));

  /* =============== Main Loop =============== */
  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.save();
    if (state.shake>0){ ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake); }
    drawRoad();
    for (const e of state.entities) (e.type==='ob') ? drawObstacle(laneX(e.lane), e.y) : drawOrb(laneX(e.lane), e.y);
    drawPlayer(laneX(state.lane), state.playerY);
    for (const p of state.particles){ const k=1-(p.age/p.life); ctx.globalAlpha=Math.max(0,k); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    ctx.restore();
    drawGauge();
  }
  let last = now(), acc=0;
  function loop(){ if (!state.running) return; const t=now(); let dt=Math.min(34,t-last); last=t; acc+=dt; while (acc>=16){ update(16); acc-=16; } draw(); requestAnimationFrame(loop); }

})();</script>
</body>
</html>
