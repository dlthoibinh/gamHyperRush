<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,interactive-widget=resizes-content">

  <meta name="theme-color" content="#0ea5e9">
  <meta name="robots" content="noindex,nofollow">
  <title>HyperRush ‚Äî Freeze Edition</title>
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root{ --brand:#0ea5e9; --bg:#0b1220; --card:#0f172a; --text:#e5f0ff; --muted:#93a4c3; --ok:#16a34a; --bad:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0b1326 60%,#0b1220);color:var(--text);
         font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
         touch-action:manipulation;-webkit-tap-highlight-color:transparent;outline:0;
         min-height:100dvh;}
    
    /* FULLSCREEN: b·ªè max-width, b√°m theo viewport th·ª±c */
    #wrap{
      position:fixed; inset:0;            /* chi·∫øm tr·ªçn m√†n h√¨nh */
      width:100vw; height:100dvh;
      margin:0; max-width:none;           /* << b·ªè 480px g√¢y co nh·ªè */
      overflow:hidden;
    }
    
    /* ƒë√£ c√≥ r·ªìi nh∆∞ng ƒë·ªÉ ch·∫Øc ch·∫Øn */
    #game{display:block;width:100%;height:100%;background:
      radial-gradient(ellipse at 50% -10%,rgba(14,165,233,.25),transparent 55%),
      linear-gradient(180deg,#0a0f1c,#0b1220)}
    
    /* fallback cho m√°y c≈© kh√¥ng h·ªó tr·ª£ dvh */
    @supports not (height: 100dvh) {
      #wrap{ height:100vh; }
    }

    .ui{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
    .card{background:rgba(15,23,42,.82);backdrop-filter:blur(8px);border:1px solid rgba(148,163,184,.15);border-radius:16px;padding:18px 16px;max-width:420px;width:100%;box-shadow:0 20px 50px rgba(14,165,233,.08)}
    h1{font-size:22px;margin:0 0 4px;letter-spacing:.2px}
    p{margin:4px 0 10px;color:var(--muted);font-size:14px}
    .row{display:flex;gap:10px;margin-top:10px;align-items:center}
    button{flex:1;border:0;border-radius:12px;background:var(--brand);color:#fff;font-weight:700;padding:12px 14px;font-size:16px;box-shadow:0 10px 30px rgba(14,165,233,.25);cursor:pointer}
    button:active{transform:translateY(1px)}
    input[type="text"]{flex:1;background:#0b1220;border:1px solid rgba(148,163,184,.2);border-radius:12px;color:#fff;padding:10px 12px;outline:none}
    label.switch{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;font-weight:700;text-shadow:0 2px 10px rgba(0,0,0,.4);z-index:40}
    .pill{background:rgba(2,6,23,.55);border:1px solid rgba(148,163,184,.15);padding:8px 12px;border-radius:999px}
    .hint{font-size:12px;color:var(--muted)}
    .small{font-size:12px}
    .center{text-align:center}
    .mt8{margin-top:8px}
    .row-small{display:flex;gap:8px;margin-top:8px}

    #gauge{position:absolute;right:8px;top:46px;width:64px;height:64px;border-radius:999px;background:rgba(2,6,23,.45);border:1px solid rgba(148,163,184,.15);display:flex;align-items:center;justify-content:center;z-index:50;pointer-events:none}
    #gcv{width:56px;height:56px;display:block}
    #toast{position:absolute;left:50%;top:58px;transform:translateX(-50%);padding:6px 10px;background:rgba(250,250,250,.12);border:1px solid rgba(255,255,255,.2);border-radius:999px;font-size:12px;opacity:0;transition:opacity .18s, transform .18s;z-index:45}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
    [hidden]{display:none !important;}

    #game{ touch-action:none; }
    html,body,#wrap{ overscroll-behavior:none; }

    .touch-ctrl{ position:absolute;left:0;right:0;bottom:18px; display:flex;justify-content:space-between;padding:0 18px;pointer-events:none;z-index:35 }
    .touch-ctrl button{ width:64px;height:64px;border-radius:999px;border:0;background:rgba(2,6,23,.35);color:#fff;font-size:22px;border:1px solid rgba(148,163,184,.18);box-shadow:0 10px 20px rgba(0,0,0,.2); pointer-events:auto }

    #tut{position:absolute;inset:0;background:rgba(2,6,23,.7);display:flex;align-items:center;justify-content:center;z-index:60}
    #tut .card{max-width:460px}

    @media (prefers-reduced-motion: reduce){
      #toast{transition:none}
    }
    :root{
      /* s·∫Ω ƒë∆∞·ª£c JS c·∫≠p nh·∫≠t m·ªói l·∫ßn fitCanvas() ch·∫°y */
      --cw: 360px; /* canvas width hi·ªÉn th·ªã */
      --ch: 640px; /* canvas height hi·ªÉn th·ªã */
    }
    
    /* #wrap chi·∫øm tr·ªçn m√†n h√¨nh + cƒÉn gi·ªØa canvas ·ªü PC */
    #wrap{
      position: fixed; inset: 0;
      width: 100vw; height: 100dvh;           /* full m√†n h√¨nh th·ª±c tr√™n mobile */
      margin: 0; max-width: none; overflow: hidden;
      display: grid; place-items: center;      /* canvas v√†o ƒë√∫ng gi·ªØa */
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        calc(env(safe-area-inset-bottom) + 8px)
        env(safe-area-inset-left);
    }
    
    /* Canvas c√≥ bo g√≥c + b√≥ng nh·∫π cho PC */
    #game{ border-radius: 14px; box-shadow: 0 28px 80px rgba(14,165,233,.12); }
    
    /* HUD b√°m theo b·ªÅ r·ªông canvas (ƒë·∫πp tr√™n PC, kh√¥ng l·ªách tr√°i) */
    .hud{
      position: absolute;
      top: max(8px, env(safe-area-inset-top));
      left: 50%; transform: translateX(-50%);
      width: var(--cw);                         /* cƒÉn theo canvas */
      padding: 8px 12px;
    }
    
    /* Gauge b√°m m√©p ph·∫£i c·ªßa canvas (kh√¥ng d·∫°t ra r√¨a m√†n h√¨nh) */
    #gauge{
      position: absolute;
      top: calc(max(46px, env(safe-area-inset-top) + 38px));
      right: calc(50% - var(--cw)/2 + 8px);     /* m√©p ph·∫£i canvas + 8px */
    }
    
    /* Toast gi·ªØ theo t√¢m canvas */
    #toast{
      left: 50%; transform: translateX(-50%);
    }
    
    /* C·ª•m n√∫t ch·∫°m b√°m ƒë√°y canvas + safe-area */
    .touch-ctrl{
      position: absolute; left: 50%; transform: translateX(-50%);
      width: var(--cw);
      bottom: max(18px, env(safe-area-inset-bottom));
      padding: 0 18px;
    }
    
    /* TƒÉng c·ª° ch·ªØ HUD theo m√†n l·ªõn nh∆∞ng kh√¥ng qu√° to */
    .pill{ font-size: clamp(12px, 1.2vw, 16px); }
    
    /* PC l·ªõn: bo g√≥c & b√≥ng ƒë·∫≠m h∆°n ch√∫t */
    @media (min-width: 900px){
      #game{ border-radius: 18px; }
    }
    /* ==== Energy bar ==== */
    #energyWrap{
      flex:1;
      height:10px;                /* ƒë·ªô cao bar */
      margin:0 12px;
      background:rgba(2,6,23,.55);
      border:1px solid rgba(148,163,184,.15);
      border-radius:999px;
      overflow:hidden;
    }
    #energyFill{
      height:100%;
      width:100%;                 /* s·∫Ω b·ªã JS ch·ªânh % */
      background:linear-gradient(90deg,#16a34a,#22d3ee);
      transition:width .15s linear;
    }
    #aboutBar{
      position: absolute;
      left: 8px;
      bottom: max(8px, env(safe-area-inset-bottom));
      font-size: 12px;
      color: var(--muted);
      opacity: .65;
      pointer-events: none;      /* kh√¥ng c·∫£n n√∫t c·∫£m ·ª©ng */
      z-index: 70;               /* cao h∆°n canvas */
    }

  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640" aria-label="HyperRush Freeze"></canvas>
    <div id="aboutBar">
      <span id="verLabel"></span> ‚Ä¢ <span id="authorLabel"></span>
    </div>
    <div id="uiStart" class="ui" role="dialog" aria-modal="true">
      <div class="card">
        <h1>HyperRush ‚Äî Freeze</h1>
        <p>Gi·ªØ ch·∫°m ƒë·ªÉ <b>Freeze</b>. Vu·ªët ngang ƒë·ªÉ <b>k√©o</b> nh√¢n v·∫≠t ‚Äì kh√¥ng nh·∫£y b·∫≠c.</p>
        <div class="row">
          <input id="name" type="text" maxlength="16" placeholder="T√™n hi·ªÉn th·ªã (tu·ª≥ ch·ªçn)">
          <button id="btnPlay">Ch∆°i ngay</button>
        </div>
        <div class="row-small">
          <label class="switch"><input id="optTilt" type="checkbox"> Nghi√™ng m√°y ƒë·ªÉ l√°i</label>
          <label class="switch"><input id="optBgm" type="checkbox"> Nh·∫°c n·ªÅn</label>
        </div>
        <p class="hint">PC: A/D ho·∫∑c ‚Üê ‚Üí; Space = Freeze ‚Ä¢ Mobile: vu·ªët li√™n t·ª•c, ch·∫°m tr√°i/ph·∫£i ƒë·ªÉ ƒë·ªïi l√†n nhanh.</p>
        <div class="small">B·∫£n ƒë·ªì thay ƒë·ªïi m·ªói ng√†y. C·ªë g·∫Øng v∆∞·ª£t 2.500!</div>
        <div class="row-small">
          <button id="btnTop">Top 100 ng√†y</button>
          <button id="btnTut">H∆∞·ªõng d·∫´n</button>
        </div>
      </div>

    </div>

    <div id="uiHUD" class="hud" hidden>
      <div class="pill">ƒêi·ªÉm: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill small" id="stageLabel">Stage 1</div>
      <div class="pill small" id="playerName" hidden></div>
        <!-- Energy bar -->
      <div id="energyWrap">
        <div id="energyFill"></div>
      </div>

    </div>

    <div id="uiOver" class="ui" hidden role="dialog" aria-modal="true">
      <div class="card center">
        <h1>Thua r·ªìi!</h1>
        <p>ƒêi·ªÉm: <b id="finalScore">0</b> ‚Ä¢ Best: <b id="best2">0</b></p>
        <div id="overMsg" class="hint mt8"></div>
        <div class="row mt8">
          <button id="btnRetry">Ch∆°i l·∫°i</button>
          <button id="btnShare">Chia s·∫ª</button>
        </div>
        <div class="row mt8">
          <button id="btnPoster">T·∫°o ·∫£nh Poster</button>
          <button id="btnSave">T·∫£i Poster</button>
        </div>
      </div>
    </div>

    <div id="tut" hidden>
      <div class="card">
        <h1>H∆∞·ªõng d·∫´n nhanh (5s)</h1>
        <p>‚Ä¢ Gi·ªØ tay ƒë·ªÉ <b>l√†m ch·∫≠m</b> th·ªùi gian (Freeze).<br>
           ‚Ä¢ Vu·ªët <b>m∆∞·ª£t</b> ƒë·ªïi l√†n ‚Äî kh√¥ng nh·∫£y b·∫≠c. <br>
           ‚Ä¢ S∆∞·ª£t ch∆∞·ªõng ng·∫°i <b>g·∫ßn</b> s·∫Ω ƒë∆∞·ª£c c·ªông nƒÉng l∆∞·ª£ng & combo. <br>
           ‚Ä¢ Orb xanh tƒÉng ƒëi·ªÉm + nƒÉng l∆∞·ª£ng. <br>
           ‚Ä¢ M·ªói 300 ƒëi·ªÉm c√≥ <b>Stage</b> m·ªõi, c·ª≠a h·∫πp 3s.</p>
        <div class="row"><button id="btnOkTut">Hi·ªÉu r·ªìi</button></div>
      </div>
    </div>

    <div id="gauge" aria-label="Freeze energy"><canvas id="gcv" width="96" height="96"></canvas></div>
    <div id="toast">NEAR-MISS +6%</div>

    <div id="touchCtrl" class="touch-ctrl" hidden>
      <button id="btnL">‚óÄ</button>
      <button id="btnR">‚ñ∂</button>
    </div>

    <div id="topPanel" class="ui" hidden>
      <div class="card">
        <h1>B·∫£ng x·∫øp h·∫°ng ng√†y</h1>
        <div id="topList" class="small">ƒêang t·∫£i‚Ä¶</div>
        <div class="row mt8"><button id="btnCloseTop">ƒê√≥ng</button></div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /* =============== Config =============== */
  const CONFIG = {
    API_URL: 'https://script.google.com/macros/s/AKfycbznfw8rrffCKv0OObRRc8j6YHKir6dEwpLrG4eNn-Azc3xvg4_UrI3fbUoBRv6Dq-e1DQ/exec',
    AUDIO: { enabled: true, volume: 0.32, sfxUrl: '', bgmUrl: '' },
    PERF:  { dprMax: 1.35, maxEntities: 120, maxParticles: 180, minDpr: 0.85 },
    GAME: {
      lanes: 3, baseSpeed: 135, accel: 0.06,
      spawnEvery: 740, spawnAccel: 0.986,
      minSpawnEvery: 220, maxSpawnsPerFrame: 6,
      orbChance: 0.30, freezeRate: 0.28, regenPassive: 0.002,
      regenNear: 6, regenOrb: 10, freezeSlow: 0.40,
      minGapObPx: 148, minGapOrbPx: 118, minGapMixPx: 130, maxSpawnAttempts: 3,
      surgeEvery: 300, surgeMs: 3000, graceMs: 1500
    }
  };
  const META = {
    version : 'v0.9.3',        // ‚úî s·ª≠a khi b·∫°n build m·ªõi
    author  : 'L√¢m daika'    // ‚úî t√™n/nh√≥m s√°ng l·∫≠p
  };
  // ---- Hi·ªÉn th·ªã version & t√°c gi·∫£ ngay khi trang v·ª´a t·∫£i ----
  window.addEventListener('DOMContentLoaded', () => {
    // d√πng document.getElementById c≈©ng ƒë∆∞·ª£c, nh∆∞ng $ ƒë√£ c√≥ s·∫µn ·ªü d∆∞·ªõi
    $('#verLabel').textContent    = META.version;   // v0.9.3
    $('#authorLabel').textContent = META.author;    // L√¢m daika
  });

  const THEME_PRO = true; // true = n·ªÅn pro, false = n·ªÅn s·∫°ch t·ªëi gi·∫£n

  const TIERS = {
    base:{ maxEntities:120, maxParticles:180, minSpawnEvery:220, cap:6,  roadStep:40,  dprAdj:0 },
    mid :{ maxEntities:80,  maxParticles:90,  minSpawnEvery:280, cap:4,  roadStep:56,  dprAdj:-0.15 }, // ‚Üì 95 ‚ûú 80
    low :{ maxEntities:60,  maxParticles:60,  minSpawnEvery:320, cap:3,  roadStep:72,  dprAdj:-0.30 }  // ‚Üì 80 ‚ûú 60
  };

  /* ===== Anti-exploit ===== */
  /* ===== Anti-exploit (tinh ch·ªânh) ===== */
  const ANTI = {
    campMs: 1800,          // >1.8 s kh√¥ng ƒë·ªïi l√†n
    campCooldownMs: 1000,  // gi√£n c√°ch gi·ªØa 2 l·∫ßn √©p
    spawnJitter: 90        // ‚Üë tƒÉng bi√™n ƒë·ªô jitter (‚âà minGap/2)
  };
  /* --------- Auto-snap nh√¢n v·∫≠t v·ªÅ t√¢m l√†n --------- */
  const AUTO_SNAP = {      // T·∫Øt = ƒë·∫∑t enable:false
    enable: true,          // true = b·∫≠t
    speed : 0.12           // 0.10-0.18 ‚Üí c√†ng l·ªõn c√†ng snap nhanh
  };

  // B·∫≠t debug b·∫±ng ?debug=1
  const DBG = new URLSearchParams(location.search).get('debug') === '1';


  const LOW = (navigator.hardwareConcurrency && navigator.hardwareConcurrency<=4);
  if (LOW){ CONFIG.PERF.dprMax=1.2; CONFIG.PERF.maxParticles=140; }

  /* =============== Utils =============== */
  const $ = sel => document.querySelector(sel);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();
  const mqlReduce = matchMedia('(prefers-reduced-motion: reduce)');

  function vibrate(p){ try{ if(!mqlReduce.matches) navigator.vibrate && navigator.vibrate(p);}catch(_){ } }

  function getDeviceId(){
    const k='hrfz_device_id'; let id=localStorage.getItem(k);
    if(!id){ id=crypto.getRandomValues(new Uint32Array(4)).join('-'); localStorage.setItem(k,id); }
    return id;
  }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

  const BASE_W=360, BASE_H=640, MARGIN=40; let DPR=1, ROAD_STEP=40;

  function fitCanvas(canvas){
    const ratio = BASE_W / BASE_H;
  
    // K√≠ch th∆∞·ªõc viewport "th·ª±c" (·∫©n/hi·ªán URL bar, b√†n ph√≠m‚Ä¶)
    const w = Math.max(1, (window.visualViewport?.width || window.innerWidth));
    const h = Math.max(1, (window.visualViewport?.height || window.innerHeight));
  
    // T√≠nh size canvas theo t·ªâ l·ªá 360x640
    let cw = w, ch = w / ratio;
    if (ch > h) { ch = h; cw = h * ratio; }
  
    // Style k√≠ch th∆∞·ªõc hi·ªÉn th·ªã
    canvas.style.width  = cw + 'px';
    canvas.style.height = ch + 'px';
  
    // C·∫≠p nh·∫≠t bi·∫øn CSS ƒë·ªÉ HUD/gauge/n√∫t b√°m theo ƒë√∫ng b·ªÅ r·ªông canvas
    document.documentElement.style.setProperty('--cw', cw + 'px');
    document.documentElement.style.setProperty('--ch', ch + 'px');
  
    // DPR an to√†n theo c·∫•u h√¨nh hi·ªáu nƒÉng
    const dprTarget = clamp((window.devicePixelRatio || 1), CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    DPR = dprTarget;
  
    // K√≠ch th∆∞·ªõc buffer v·∫Ω
    canvas.width  = Math.round(BASE_W * DPR);
    canvas.height = Math.round(BASE_H * DPR);
  
    // Scale h·ªá to·∫° ƒë·ªô v·ªÅ ƒë∆°n v·ªã logic (BASE_W x BASE_H)
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }



  function dailySeed(){
    const d=new Date(); const s=Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())>>>0;
    return s ^ (getDeviceId().split('-')[0]>>>0);
  }

  /* ====== Spawn table ƒë·ªông ====== */
  // ‚ú® Kho·∫£ng c√°ch t·ªëi thi·ªÉu t√πy c·∫∑p lo·∫°i
  function needGapBetween(typeA, typeB){
    if (typeA === 'ob'  && typeB === 'ob')  return CONFIG.GAME.minGapObPx;
    if (typeA === 'orb' && typeB === 'orb') return CONFIG.GAME.minGapOrbPx;
    return CONFIG.GAME.minGapMixPx; // kh√°c lo·∫°i
  }
  
  // ‚ú® Lane c√≥ ƒë·ªß kho·∫£ng c√°ch ƒë·ªÉ spawn y0 cho 'type' kh√¥ng?
  function okGapForLane(lane, type, y0){
    // y tƒÉng theo chi·ªÅu xu·ªëng; spawn ·ªü y0 √¢m ‚áí y0 ph·∫£i "tr√™n" ƒë·ªß xa so v·ªõi m·ªçi entity c√πng l√†n
    for (let i = state.entities.length - 1; i >= 0; i--){
      const e = state.entities[i];
      if (e.lane !== lane) continue;
      const need = needGapBetween(type, e.type);
      if ((y0 - e.y) > -need) return false; // ch∆∞a ƒë·ªß kho·∫£ng c√°ch
    }
    return true;
  }
  // --- Utils tr√°nh spawn "b·ªãt 3 c·ªôt" ---
  function rowBlocked(y0){
    // qu√©t ¬±minGapObPx quanh to·∫° ƒë·ªô Y chu·∫©n b·ªã spawn
    const band = CONFIG.GAME.minGapObPx;
    const occ  = new Array(CONFIG.GAME.lanes).fill(false);
  
    for (const e of state.entities){
      if (e.type !== 'ob') continue;               // ch·ªâ x√©t obstacle
      if (Math.abs(e.y - y0) <= band) occ[e.lane] = true;
    }
    return occ.every(Boolean);                    // true = c·∫£ 3 lane ƒë√£ k√≠n
  }

  function makeSpawnTable(base, accel, minMs, limit=4096){
    const out=[]; let v=base, i=0;
    while (i<limit && v>minMs){ out.push(v); v*=accel; i++; }
    out.push(minMs); return new Float32Array(out);
  }
  let SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  function rebuildSpawnTable(minMs){
    CONFIG.GAME.minSpawnEvery = minMs;
    SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  }

  /* ----- Hitbox & h√¨nh h·ªçc ----- */
  const HIT = { P_W:30, P_H:30, OB_W:36, OB_H:36, NEAR_PAD:8 };
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return (Math.abs(ax - bx) <= (aw + bw) * 0.5) && (Math.abs(ay - by) <= (ah + bh) * 0.5);
  }
  function laneWidth(){ return (W - MARGIN*2)/CONFIG.GAME.lanes; }

  /* ====== Link c·∫£nh b√°o gi·ªØa 2 l√†n ====== */
  const links = []; // {y, age, life, strong}
  function addLink(y, strong){
    if (links.length>24) links.shift();
    links.push({y, age:0, life:420, strong:!!strong});
  }

  /* =============== Audio =============== */
  const AudioKit = (function(){
    let ctx, master, sfxBuf=null, bgm=null, bgmGain=null;
    function ensure(){
      if (!CONFIG.AUDIO.enabled) return null;
      if (!ctx){ ctx=new (window.AudioContext||window.webkitAudioContext)(); master=ctx.createGain(); master.gain.value=CONFIG.AUDIO.volume; master.connect(ctx.destination); }
      return ctx;
    }
    async function load(url){ const c=ensure(); if(!c||!url) return null;
      try{ const r=await fetch(url); const a=await r.arrayBuffer(); return await c.decodeAudioData(a);}catch(_){return null;}
    }
    async function prepare(){ if(!ensure()) return; if(CONFIG.AUDIO.sfxUrl && !sfxBuf) sfxBuf=await load(CONFIG.AUDIO.sfxUrl); }
    function unlock(){ const c=ensure(); if(!c) return; if(c.state==='suspended') c.resume().catch(()=>{}); }
    function playBuf(buf,time=0,off=0,dur){ if(!buf) return; const c=ensure(); const src=c.createBufferSource(); src.buffer=buf; src.connect(master); if(dur) src.start(c.currentTime+time,off,dur); else src.start(c.currentTime+time,off); }
    const SPR={ move:[0.00,0.08], near:[0.10,0.10], orb:[0.22,0.16], freeze_on:[0.40,0.12], hit:[0.56,0.22], taunt:[0.80,0.20] };
    function tone(o){ const c=ensure(); if(!c) return; const osc=c.createOscillator(), g=c.createGain();
      osc.type=o.type||'sine'; osc.frequency.value=o.freq||440; if(o.detune) osc.detune.value=o.detune;
      g.gain.value=0; osc.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, d=o.decay||0.12, s=o.sustain||0.0001, r=o.release||0.08, v=o.gain||0.4;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(s,t+a+d); g.gain.linearRampToValueAtTime(0,t+a+d+r);
      osc.start(t); osc.stop(t+a+d+r+0.01);
    }
    function noise(o){ const c=ensure(); if(!c) return;
      const b=c.createBuffer(1, c.sampleRate*0.18, c.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1);
      const src=c.createBufferSource(); src.buffer=b; const g=c.createGain(); g.gain.value=0; src.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, r=o.release||0.14, v=o.gain||0.45;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(0,t+a+r);
      src.start(t); src.stop(t+a+r+0.01);
    }
    function sfx(n){
      if (sfxBuf && SPR[n]){ const [off,dur]=SPR[n]; return playBuf(sfxBuf,0,off,dur); }
      switch(n){ case 'move': tone({type:'square',freq:640,gain:0.18,decay:0.06,release:0.06}); break;
        case 'near': tone({type:'triangle',freq:880,gain:0.22,decay:0.04}); break;
        case 'orb':  tone({type:'sine',freq:520,gain:0.26,decay:0.05}); tone({type:'sine',freq:780,gain:0.20,decay:0.07}); break;
        case 'freeze_on': tone({type:'sawtooth',freq:300,gain:0.18,decay:0.08}); break;
        case 'hit':  noise({gain:0.6}); tone({type:'square',freq:140,gain:0.25,decay:0.09,release:0.2}); break;
        case 'taunt': tone({type:'triangle',freq:480,gain:0.16,decay:0.12}); break; }
    }
    async function startBgm(){ if(!CONFIG.AUDIO.bgmUrl) return; const c=ensure(); if(!c) return;
      if(!bgm){ const buf=await load(CONFIG.AUDIO.bgmUrl); if(!buf) return;
        const src=c.createBufferSource(); src.buffer=buf; src.loop=true; bgmGain=c.createGain(); bgmGain.gain.value=0; src.connect(bgmGain); bgmGain.connect(master); src.start();
        bgm=src; const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0.25,t+1.2); } }
    function stopBgm(){ if(bgmGain){ const c=ensure(); const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0,t+0.6); } }
    return {unlock,prepare,sfx,startBgm,stopBgm};
  })();

  /* =============== Backend =============== */
  async function postScore(payload) {
    if (!CONFIG.API_URL) return;
    try {
      await fetch(CONFIG.API_URL, {
        method:'POST', mode:'cors', headers:{'Content-Type':'text/plain'},
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined
      }).catch(()=>{});
    } catch (_){}
  }
  async function fetchTop(){
    if (!CONFIG.API_URL) throw 'No API';
    const url = CONFIG.API_URL + '?top=100';
    const r = await fetch(url, {mode:'cors', signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined});
    return await r.json();
  }

  /* =============== Game State =============== */
  const canvas = $('#game'); 
  const ctx = canvas.getContext('2d');
  fitCanvas(canvas);
  addEventListener('resize', () => fitCanvas(canvas));
  if (window.visualViewport){
    visualViewport.addEventListener('resize', () => fitCanvas(canvas));
    visualViewport.addEventListener('scroll',  () => fitCanvas(canvas)); // khi URL bar tr∆∞·ª£t
  }
  new ResizeObserver(() => fitCanvas(canvas)).observe($('#wrap'));

  
  const gcv = $('#gcv'); 
  const gctx = gcv.getContext('2d');

  const energyFill = $('#energyFill');

  let W=BASE_W, H=BASE_H;
  const state = {
    running:false, over:false, startedAt:0, playMs:0,
    name:'', score:0, best:Number(localStorage.getItem('hrfz_best')||0),
    rng: mulberry32(dailySeed()),
    speed: CONFIG.GAME.baseSpeed,
    lastSpawn: 0, spawnIdx: 0,
    lane: 1.0, desiredLane: 1.0, laneV:0,
    playerY: H * 0.6,
    entities: [],
    energy: 60,
    holding:false,
    lastNearT: 0,
    shake: 0,
    particles: [],
    surgeMs: 0, nextSurge: CONFIG.GAME.surgeEvery,
    dragging:false, dragStartX:0, dragStartLane:1.0, hasDragged:false, dragStartT:0, lastDragT: 0,
    combo:0, comboT:0,
    grace: CONFIG.GAME.graceMs,
    stage:1, lastStageAnnounce:0,
    nearMissCount:0,
    lowSpec:false, fpsEMA:60,
    gfxTier:0, _tierLockT:0, frame:0,
    lastSlipT:0,    
    energyEmptyT: 0, 
    lastLaneChangeT: now(),      // l·∫ßn g·∫ßn nh·∫•t ƒë·ªïi l√†n nguy√™n
    _laneI: 1,                   // l√†n nguy√™n hi·ªán t·∫°i (ƒë·ªÉ so s√°nh)
    _antiCampT: 0,               // cooldown anti-camp

  };

  /* =============== Particles =============== */
  function spawnParticles(x,y,color,count=12,spd=1){
    const allow = Math.max(0, CONFIG.PERF.maxParticles - state.particles.length);
    count = Math.min(count, allow);
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      state.particles.push({ x,y, vx: Math.cos(a)*(1.2+Math.random()*2)*spd, vy: Math.sin(a)*(1.2+Math.random()*2)*spd,
        life: 420+Math.random()*260, age:0, color });
    }
  }

  /* =============== Input =============== */
  function stepLane(dir){
    const next = clamp(Math.round(state.desiredLane) + Math.sign(dir), 0, CONFIG.GAME.lanes-1);
    if (next!==Math.round(state.desiredLane)){ state.desiredLane = next; AudioKit.sfx('move'); }
  }
  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowleft'||k==='a') stepLane(-1);
    if (k==='arrowright'||k==='d') stepLane(1);
    if (k===' ') { state.holding = true; AudioKit.sfx('freeze_on'); }
  }, {passive:true});
  addEventListener('keyup', (e)=>{ if (e.key===' ') state.holding=false; }, {passive:true});

  const TAP_TIME_MAX=160;
  const DRAG_PX_THRESHOLD=10*(window.devicePixelRatio||1);

  canvas.addEventListener('pointerdown', async (e)=>{
    if (state.dragging) return;
    state.dragging=true; state.dragStartX=e.clientX; state.dragStartLane=state.desiredLane; state.dragStartT=now();
    state.hasDragged=false; canvas.setPointerCapture?.(e.pointerId);
    state.holding=true; await AudioKit.prepare(); AudioKit.unlock(); AudioKit.sfx('freeze_on'); e.preventDefault();
    state.lastDragT = now(); 
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (!state.dragging) return;
    const dx=e.clientX-state.dragStartX;
    if (Math.abs(dx)>DRAG_PX_THRESHOLD) state.hasDragged=true;
    const laneW=(W-MARGIN*2)/CONFIG.GAME.lanes;
    const cont=state.dragStartLane + dx/laneW;
    state.desiredLane=clamp(cont,0,CONFIG.GAME.lanes-1); e.preventDefault();
    state.lastDragT = now();  
  }, {passive:false});
  function endPointer(e){
    if (!state.dragging) return;
    try{ canvas.releasePointerCapture?.(e.pointerId);}catch(_){}
    const dtTap=now()-(state.dragStartT||0);
    const dx=Math.abs((e.clientX||0)-(state.dragStartX||0));
    if (!state.hasDragged && dtTap<=TAP_TIME_MAX && dx<DRAG_PX_THRESHOLD){
      const r=canvas.getBoundingClientRect(); stepLane(e.clientX < r.left+r.width/2 ? -1 : 1);
    }
    state.dragging=false; state.holding=false; e.preventDefault();
  }
  canvas.addEventListener('pointerup', endPointer, {passive:false});
  canvas.addEventListener('pointercancel', endPointer, {passive:false});
  canvas.addEventListener('pointerleave', endPointer, {passive:false});

  $('#optTilt').addEventListener('change', async (e)=>{
    if (e.target.checked){
      try{
        if (typeof DeviceMotionEvent!=='undefined' && DeviceMotionEvent.requestPermission){
          const perm=await DeviceMotionEvent.requestPermission(); if (perm!=='granted') e.target.checked=false;
        }
      }catch(_){}
    }
  }, {passive:true});
  addEventListener('devicemotion', (ev)=>{
    if (!$('#optTilt').checked || !state.running) return;
    const ax = ev.accelerationIncludingGravity ? ev.accelerationIncludingGravity.x||0 : 0;
    const tilt=clamp(ax/6,-1,1);
    state.desiredLane=clamp(1+tilt,0,CONFIG.GAME.lanes-1);
  }, {passive:true});

  /* =============== Helpers =============== */
  function smoothLane(dt){
    const k=28, c=2*Math.sqrt(k), x=state.lane-state.desiredLane, a=-k*x - c*state.laneV, dtSec=dt/1000;
    state.laneV += a*dtSec; state.lane += state.laneV*dtSec; state.lane=clamp(state.lane,0,CONFIG.GAME.lanes-1);
  }
  function applyStages(){
    const s = Math.floor(state.score/CONFIG.GAME.surgeEvery)+1;
    if (s!==state.stage){
      state.stage=s; $('#stageLabel').textContent=`Stage ${state.stage}`;
      CONFIG.GAME.orbChance = Math.max(0.18, 0.30 - 0.01*(state.stage-1));
      CONFIG.GAME.minGapObPx = clamp(148 - 4*(state.stage-1), 120, 148);
      if (now()-state.lastStageAnnounce>2000){ toast(`Stage ${state.stage}!`); AudioKit.sfx('taunt'); }
      state.lastStageAnnounce=now();
    }
  }

  /* ====== Auto tune perf by FPS/Stage ====== */
  function applyTier(tierName){
    const t = TIERS[tierName];
    CONFIG.PERF.maxEntities = t.maxEntities;
    CONFIG.PERF.maxParticles = t.maxParticles;
    CONFIG.GAME.maxSpawnsPerFrame = t.cap;
    ROAD_STEP = t.roadStep;
    rebuildSpawnTable(t.minSpawnEvery);

    const newDpr = clamp(DPR + t.dprAdj, CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    if (Math.abs(newDpr - DPR) > 0.01){
      DPR = newDpr; fitCanvas(canvas);
    }
  }
  function autoTune(){
    if (now() - state._tierLockT < 1500) return;
    let target = 0;
    if (state.fpsEMA < 48 || state.stage >= 10) target = 1;
    if (state.fpsEMA < 42 || state.stage >= 12) target = 2;
    if (target !== state.gfxTier){
      state.gfxTier = target;
      applyTier(target===2 ? 'low' : target===1 ? 'mid' : 'base');
      state._tierLockT = now();
    }
  }

  /* =============== Update =============== */
  function update(dt) {
    const timeScale = state.holding && state.energy>0 ? CONFIG.GAME.freezeSlow : 1;
    const dtEff = dt * timeScale;

    if (state.grace>0) state.grace = Math.max(0, state.grace - dt);

    const passive = state.holding ? 0 : CONFIG.GAME.regenPassive * (dt/10);
    state.energy = Math.min(
        100,
        (state.holding
            ? state.energy - CONFIG.GAME.freezeRate * (dt/10)   // ƒëang Freeze ‚Üí hao
            : state.energy                                      // kh√¥ng Freeze ‚Üí gi·ªØ nguy√™n
        )
        + passive                                               // ch·ªâ h·ªìi khi kh√¥ng Freeze
    );

    drawEnergyBar();
    /* --- Death on zero energy --- */
    if (state.energy <= 0){
      if (!state.energyEmptyT) state.energyEmptyT = now();           // ƒë√°nh d·∫•u
      else if (now() - state.energyEmptyT > 5000){                   // >2 s
        toast('Ki·ªát s·ª©c!');
        boom(); AudioKit.sfx('hit'); vibrate([60,40,100]);
        return gameOver();
      }
    }else{
      state.energyEmptyT = 0;  // reset khi c√≥ nƒÉng l∆∞·ª£ng l·∫°i
    }

    state.speed += CONFIG.GAME.accel * dtEff/16.6;
    state.spawnIdx += dtEff/16.6;
    const spawnEvery = SPAWN_TABLE[Math.min(SPAWN_TABLE.length-1, state.spawnIdx|0)];
    state.score += dtEff * 0.06 * ( (state.lastNearT && (now()-state.lastNearT<1200)) ? 1.15 : 1 );
    $('#score').textContent = String(Math.floor(state.score));

    smoothLane(dtEff);
    /* ===== Auto-snap v·ªÅ gi·ªØa l√†n (khi bu√¥ng tay) ===== */
    const idleTooLong = state.dragging && (now() - state.lastDragT > 300);
    if (AUTO_SNAP.enable && !state.holding && (!state.dragging || idleTooLong)) {
      const nearest = Math.round(state.desiredLane);     // l√†n chu·∫©n (0,1,2‚Ä¶)
      const diff    = nearest - state.desiredLane;
      if (Math.abs(diff) > 0.001) {                      // c√≤n l·ªách
        state.desiredLane += diff * AUTO_SNAP.speed;     // n·ªôi suy √™m
        if (Math.abs(nearest - state.desiredLane) <= 0.02){
          state.desiredLane = nearest;                   // ch·ªët c·ª©ng
          state.laneV = 0;                               // d·ª´ng dao ƒë·ªông
        }
      }
    }

    /* Theo d√µi ƒë·ªïi l√†n nguy√™n ƒë·ªÉ reset ƒë·ªìng h·ªì camping */
    {
      const li = Math.round(state.desiredLane);
      if (li !== state._laneI) {
        state._laneI = li;
        state.lastLaneChangeT = now();
      }
    }

    applyStages();

    if (state.score >= state.nextSurge){ state.surgeMs = CONFIG.GAME.surgeMs; state.nextSurge += CONFIG.GAME.surgeEvery; toast('C·ª≠a h·∫πp 3s!'); AudioKit.sfx('taunt'); }
    if (state.surgeMs>0) state.surgeMs = Math.max(0, state.surgeMs - dt);

    state.lastSpawn += dtEff;
    const spawnMul = state.surgeMs>0 ? 0.7 : 1;
    let spawned=0;
    const cap = Math.min(CONFIG.GAME.maxSpawnsPerFrame, CONFIG.PERF.maxEntities - state.entities.length);
    while (state.lastSpawn >= spawnEvery * spawnMul && spawned < cap) {
      state.lastSpawn -= spawnEvery * spawnMul;
      const times = 1 + (state.surgeMs>0 ? 1 : 0);
      for (let k=0;k<times;k++) trySpawn();
      spawned++;
    }
    if (spawned >= cap && state.lastSpawn > spawnEvery * spawnMul * 4) state.lastSpawn = 0;

    const px = laneX(state.lane), py = state.playerY;
    let eLnear = null, eRnear = null; // ƒë·ªÉ v·∫Ω link / bonus

    for (let i=state.entities.length-1;i>=0;i--) {
      const e = state.entities[i]; e.y += state.speed * dtEff/1000;
      const ex = laneX(e.lane), ey = e.y;

      if (e.type === 'orb') {
        const hitOrb = aabb(px, py, HIT.P_W, HIT.P_H, ex, ey, 22, 22);
        if (hitOrb) {
          state.score += 50; state.energy = Math.min(100, state.energy + CONFIG.GAME.regenOrb);
          state.entities.splice(i,1); flash(120); spawnParticles(px,py,'#38bdf8',12,1.1); AudioKit.sfx('orb'); vibrate(12);
          continue;
        }
      }

      if (e.type === 'ob') {
        const collided = (state.grace<=0) && aabb(px,py,HIT.P_W,HIT.P_H, ex,ey,HIT.OB_W,HIT.OB_H);
        const near = !collided && aabb(px,py,HIT.P_W+HIT.NEAR_PAD,HIT.P_H+HIT.NEAR_PAD, ex,ey,HIT.OB_W+HIT.NEAR_PAD,HIT.OB_H+HIT.NEAR_PAD);

        if (near && !e.nearDone && now() - state.lastNearT > 240) {
            state.nearMissCount++;
        
            if (now() - state.comboT < 1200) state.combo++;
            else                             state.combo = 1;
            state.comboT = now();
        
            const bonus = CONFIG.GAME.regenNear + Math.min(12, 2 * Math.max(0, state.combo - 1));
            state.energy = Math.min(100, state.energy + bonus);
            state.score  += 4 * state.combo;
        
            toast(state.combo > 1
                  ? `NEAR-MISS x${state.combo} +${bonus}%`
                  : `NEAR-MISS +${CONFIG.GAME.regenNear}%`);
        
            state.lastNearT = now();
            AudioKit.sfx('near');
            vibrate(10);
        
            e.nearDone = true;   // kh√≥a l·∫°i cho t·ªõi khi kh·ªëi v∆∞·ª£t qua ƒë·∫ßu ng∆∞·ªùi ch∆°i
        }

        if (collided) {
          if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
          boom(); spawnParticles(px,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
          return gameOver();
        }

        // Ghi nh·∫≠n hai kh·ªëi ·ªü 2 l√†n k·ªÅ nhau quanh ng∆∞·ªùi ch∆°i ƒë·ªÉ x·ª≠ l√Ω link/bonus
        const L = Math.floor(state.lane), R = L+1;
        if (e.lane===L && Math.abs(ey - py) < 34) eLnear = e;
        if (e.lane===R && Math.abs(ey - py) < 34) eRnear = e;
      }

      if (e.y - py > HIT.OB_H) e.nearDone = false;
      if (e.y > H+50) state.entities.splice(i,1);
    }

    /* ===== C√¥ng b·∫±ng ‚Äúƒëi gi·ªØa 2 c·ªôt‚Äù: ch·ªâ x·ª≠ thua n·∫øu khe th·∫≠t s·ª± KH√îNG L·ªåT ===== */
    if (state.grace <= 0) {
      const frac = state.lane - Math.floor(state.lane);
      if (frac > 0.44 && frac < 0.56) {
        const L = Math.floor(state.lane), R = L + 1;
        if (eLnear && eRnear) {
          const laneW = laneWidth();
          const gapBetweenInnerEdges = laneW - 2*(HIT.OB_W/2); // = laneW - 36
          const needToPass = HIT.P_W + 6; // ng∆∞·ªùi ch∆°i + bi√™n an to√†n
          const impossible = gapBetweenInnerEdges < needToPass;

          // hi·ªÉn th·ªã ch·∫•m ƒë·ªè gi·ªØa 2 kh·ªëi (ƒë·∫≠m n·∫øu impossible)
          addLink(py, impossible);

          if (impossible) {
            if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
            const pxMid = laneX(state.lane); boom(); spawnParticles(pxMid,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
            return gameOver();
          } else {
            // th∆∞·ªüng SLIP nh·ªè khi l·ªçt khe h·∫πp (cooldown)
            if (now()-state.lastSlipT>800) {
              state.lastSlipT = now();
              state.score += 12;
              state.energy = Math.min(100, state.energy + 4);
              toast('SLIP +12');
              AudioKit.sfx('near');
            }
          }
        }
      }
    }

    // Particles
    const pf = state.lowSpec ? 0.7 : 1;
    for (let i=state.particles.length-1;i>=0;i--){
      const p=state.particles[i]; p.age += dtEff; if (p.age>p.life){ state.particles.splice(i,1); continue; }
      p.x += p.vx * dtEff/16.6; p.y += p.vy * dtEff/16.6; p.vy += 0.002*dtEff*pf;
    }
    // links age
    for (let i=links.length-1;i>=0;i--){ links[i].age += dtEff; if (links[i].age>links[i].life) links.splice(i,1); }

    state.shake *= mqlReduce.matches ? 0.9 : 0.92;
  }
  /* G·ª£i √Ω l√†n ƒë·ªÉ ph√° "h√†nh lang" (2 k√≠n, 1 tr·ªëng trong c√πng d·∫£i y) */
  /* G·ª£i √Ω l√†n ƒë·ªÉ ph√° "h√†nh lang" (2 k√≠n, 1 tr·ªëng trong d·∫£i y g·∫ßn nhau) */
  /* ---------- B·∫ª ‚Äúh√†nh lang an to√†n‚Äù ---------- */
  function corridorSuggest(y){
    // qu√©t d·∫£i ¬±band quanh y
    const band = CONFIG.GAME.minGapObPx + ROAD_STEP;  // r·ªông h∆°n ‚Üí b·∫Øt ƒë·ªß 2 c·ªôt
    const occ  = new Array(CONFIG.GAME.lanes).fill(false);
  
    for (const e of state.entities){
      if (e.type !== 'ob') continue;
      if (Math.abs(e.y - y) <= band) occ[e.lane] = true;
    }
    let empty = -1, filled = 0;
    for (let i = 0; i < occ.length; i++){
      if (occ[i]) filled++; else empty = i;
    }
    return (filled === CONFIG.GAME.lanes - 1) ? empty : -1;
  }



  /* ====== Spawn kh·ªëi ====== */
  function trySpawn(){
    if (state.entities.length >= CONFIG.PERF.maxEntities) return;
  
    const early = (state.score < 80);
    const type  = (state.rng() < (early ? 0.4 : CONFIG.GAME.orbChance)) ? 'orb' : 'ob';
    if (early && type === 'ob') return;            // giai ƒëo·∫°n d·ªÖ
  
    let lane  = Math.floor(state.rng() * CONFIG.GAME.lanes);
    let tries = 0;
  
    /* 1. Anti-camping */
    if (type === 'ob'
        && now() - state.lastLaneChangeT > ANTI.campMs
        && now() - state._antiCampT      > ANTI.campCooldownMs){
      lane = Math.round(state.lane);               // ch·∫∑n ngay l√†n hi·ªán t·∫°i
      state._antiCampT = now();
      if (DBG) toast('ANTI-CAMP');
    }
  
    /* 2 + 3. Jitter Y & Corridor fix */
    do {
      // Jitter 2 chi·ªÅu ¬±spawnJitter
      const jitter = (state.rng() * 2 - 1) * ANTI.spawnJitter;
      const y0 = -40 + jitter;                     // üëà ƒë·ªïi d·∫•u ¬±
  
      if (okGapForLane(lane, type, y0) &&
          (type !== 'ob' || !rowBlocked(y0))){       // ‚ú® NEW ch·ªët an to√†n
        state.entities.push({type, lane, y:y0, nearDone:false});
        return;
      }

      lane = (lane + 1) % CONFIG.GAME.lanes;       // th·ª≠ l√†n kh√°c
    } while (++tries < CONFIG.GAME.maxSpawnAttempts);
  }


  /* =============== Render =============== */
  function laneX(lane){
    const roadW=W - MARGIN*2; const laneW = roadW/CONFIG.GAME.lanes;
    return Math.round(MARGIN + laneW*(0.5 + lane));
  }

  const GRAD={};
  function ensureGradients(){
    if (!GRAD.player){
      GRAD.player = ctx.createLinearGradient(-16,-16,16,16);
      GRAD.player.addColorStop(0,'#22d3ee'); GRAD.player.addColorStop(1,'#0ea5e9');
      GRAD.ob = ctx.createLinearGradient(0,-18,0,18);
      GRAD.ob.addColorStop(0,'#c64040'); GRAD.ob.addColorStop(1,'#9f2c2c');
    }
  }

  function drawRoad() {
    // N·ªÅn ch√≠nh
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#09111b'); g.addColorStop(0.55, '#0a1320'); g.addColorStop(1, '#0b1220');
    ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
  
    // V·∫°ch ph√¢n l√†n d·ªçc
    const lanes = CONFIG.GAME.lanes, roadW = W - MARGIN * 2;
    ctx.save();
    ctx.strokeStyle = 'rgba(148,163,184,0.10)'; ctx.lineWidth = 2;
    for (let i = 1; i < lanes; i++) {
      const x = MARGIN + (roadW / lanes) * i;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    ctx.restore();
  
    // Vignette & spotlight
    const spot = ctx.createRadialGradient(W/2, H*0.16, 20, W/2, H*0.16, H*0.92);
    spot.addColorStop(0, 'rgba(56,189,248,0.18)');
    spot.addColorStop(1, 'rgba(56,189,248,0.00)');
    ctx.fillStyle = spot; ctx.fillRect(0, 0, W, H);
  
    if (THEME_PRO) {
      // T·ªëi nh·∫π hai m√©p ƒë∆∞·ªùng (t·∫°o chi·ªÅu s√¢u)
      const edgeL = ctx.createLinearGradient(0, 0, MARGIN+12, 0);
      edgeL.addColorStop(0, 'rgba(0,0,0,0.35)'); edgeL.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = edgeL; ctx.fillRect(0, 0, MARGIN+12, H);
  
      const edgeR = ctx.createLinearGradient(W-(MARGIN+12), 0, W, 0);
      edgeR.addColorStop(0, 'rgba(0,0,0,0)'); edgeR.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = edgeR; ctx.fillRect(W-(MARGIN+12), 0, MARGIN+12, H);
  
      // V·ªát ‚Äúspeed glow‚Äù r·∫•t m·ªù theo stage (kh√¥ng k·∫ª v·∫°ch ngang)
      const k = Math.min(1, state.stage / 10);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.05 + 0.08 * k;
      const w = (W - MARGIN*2) * 0.9;
      ctx.beginPath();
      ctx.ellipse(W/2, H*0.55, w/2, H*0.75, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(56,189,248,0.35)';
      ctx.fill();
      ctx.restore();
    }
  }


  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }
  function drawPlayer(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(0,18,20,8,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.player; roundRect(-16,-16,32,32,8,true,false);
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(0,-8); ctx.lineTo(8,0); ctx.lineTo(0,8); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
  function drawObstacle(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.28)'; ctx.beginPath(); ctx.ellipse(0,16,16,6,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.ob; roundRect(-18,-18,36,36,8,true,false);
    ctx.strokeStyle='rgba(0,0,0,.40)'; ctx.lineWidth=1.5; roundRect(-18,-18,36,36,8,false,true);
    ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-14,-12); ctx.lineTo(14,-12); ctx.stroke();
    ctx.restore();
  }
  function drawOrb(x,y){
    ctx.save(); ctx.translate(x,y);
    const r=10+Math.sin(performance.now()/120 + x)*2;
    const g=ctx.createRadialGradient(0,0,2,0,0,r);
    g.addColorStop(0,'rgba(255,255,255,0.85)');
    g.addColorStop(1,'rgba(56,189,248,0.9)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  /* ===== V·∫Ω ch·∫•m ƒë·ªè n·ªëi gi·ªØa 2 kh·ªëi ===== */
  function drawLinks(){
    const lw = HIT.OB_W/2, xStep = 14;
    for (const L of links){
      const lifeK = Math.max(0, 1 - L.age/L.life);
      const alpha = (L.strong ? 0.55 : 0.28) * lifeK;
      const Llane = Math.floor(state.lane); // v·ªã tr√≠ lane hi·ªán t·∫°i ch·ªâ ƒë·ªÉ l·∫•y x
      const x1 = laneX(0) + (laneWidth()*Math.floor(state.lane)); // kh√¥ng d√πng lane hi·ªán t·∫°i; ta d·ª±ng chung cho m·ªçi c·∫∑p
      // v·∫Ω cho m·ªçi c·∫∑p k·ªÅ nhau
      for (let k=0; k<CONFIG.GAME.lanes-1; k++){
        const xa = laneX(k) + lw, xb = laneX(k+1) - lw;
        ctx.globalAlpha = alpha;
        for (let x=xa; x<=xb; x+=xStep){
          ctx.fillStyle = L.strong ? 'rgba(239,68,68,1)' : 'rgba(239,68,68,1)';
          ctx.beginPath(); ctx.arc(x, L.y, 2.2, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    }
  }

  /* =============== FX / Gauge / Toast =============== */
  let flashT=0, boomT=0;
  function flash(ms){ if (!mqlReduce.matches){ flashT=now()+ms; } }
  function boom(){ boomT=now()+250; state.shake = mqlReduce.matches ? 0 : 10; }
  const origFill = ctx.fillStyle;
  const _draw = draw; draw = function(){ _draw(); postFX(); };
  function postFX(){
    const t=now();
    if (flashT>t){ ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(0,0,W,H); ctx.fillStyle=origFill; }
    if (boomT>t){ const k=(boomT-t)/250; ctx.save(); ctx.translate(W/2,H/2); ctx.rotate((1-k)*0.4); ctx.scale(1+(1-k)*0.05,1+(1-k)*0.05); ctx.restore(); }
  }

  let lastGaugePct=-1;
  function drawGauge(){
    const pct = Math.floor(clamp(state.energy,0,100));
    if (pct === lastGaugePct) return; lastGaugePct=pct;
    const c=gctx; const w=gcv.width, h=gcv.height; c.clearRect(0,0,w,h);
    c.save(); c.translate(w/2,h/2);
    c.strokeStyle='rgba(148,163,184,.22)'; c.lineWidth=10; c.beginPath(); c.arc(0,0,26,0,Math.PI*2); c.stroke();
    const end = -Math.PI/2 + (pct/100)*2*Math.PI;
    const grad = c.createLinearGradient(-30,-30,30,30); grad.addColorStop(0,'#22d3ee'); grad.addColorStop(1,'#0ea5e9');
    c.strokeStyle=grad; c.lineWidth=10; c.lineCap='round'; c.beginPath(); c.arc(0,0,26,-Math.PI/2, end); c.stroke();
    c.fillStyle='rgba(255,255,255,.9)'; c.beginPath(); c.moveTo(-5,0); c.lineTo(0,-5); c.lineTo(5,0); c.lineTo(0,5); c.closePath(); c.fill();
    c.restore();
  }
  function drawEnergyBar(){
    const pct = clamp(state.energy,0,100);
    energyFill.style.width = pct + '%';
  
    /* ƒê·ªïi m√†u t·ª´ xanh‚Üív√†ng‚Üíƒë·ªè */
    if (pct > 60)      energyFill.style.background = 'linear-gradient(90deg,#16a34a,#22d3ee)';
    else if (pct > 30) energyFill.style.background = 'linear-gradient(90deg,#eab308,#facc15)';
    else               energyFill.style.background = 'linear-gradient(90deg,#ef4444,#b91c1c)';
  }

  function toast(txt){
    const el=$('#toast'); el.textContent=txt; el.classList.add('show');
    clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'),760);
  }

  /* =============== UI & Poster =============== */
  function gameOver(){
    state.running=false; state.over=true;
    state.playMs += (now()-state.startedAt);
    $('#uiHUD').hidden=true; $('#uiOver').hidden=false; $('#touchCtrl').hidden=true;
    $('#finalScore').textContent = Math.floor(state.score);
    $('#best2').textContent = state.best;
    const s=Math.floor(state.score), next=Math.ceil(s/100)*100, diff=next-s;
    $('#overMsg').textContent = (s>0 && diff>0 && diff<=12) ? `Thi·∫øu ${diff} ƒëi·ªÉm n·ªØa l√† ch·∫°m ${next}!`
      : (s>state.best ? 'K·ª∑ l·ª•c m·ªõi! L·∫ßn sau v∆∞·ª£t 2.500 nh√©.' : 'G·∫ßn th√¥i, th√™m ch√∫t ‚Äús∆∞·ª£t nh·∫π‚Äù l√† qua!');

    const payload={ deviceId:getDeviceId(), name:String(state.name||'').slice(0,16),
      score:Math.max(0,Math.floor(state.score)), tz:Intl.DateTimeFormat().resolvedOptions().timeZone||'UTC',
      ua:navigator.userAgent, seed:dailySeed(), playMs:Math.floor(state.playMs), near:state.nearMissCount,
      clientProof: crypto.subtle ? 'sha256' : '' };
    try{
      if (crypto && crypto.subtle){
        const enc=new TextEncoder().encode(payload.deviceId+'|'+payload.score+'|'+payload.seed+'|'+payload.playMs+'|'+payload.near);
        crypto.subtle.digest('SHA-256', enc).then(buf=>{
          payload.clientProof=Array.from(new Uint8Array(buf)).map(x=>x.toString(16).padStart(2,'0')).join('');
          postScore(payload);
        }).catch(()=>postScore(payload));
      } else postScore(payload);
    }catch(_){ postScore(payload); }
  }

  function resetGame(){
    state.running=true; state.over=false; state.startedAt=now(); state.playMs=0;
    state.score=0; state.speed=CONFIG.GAME.baseSpeed;
    state.lastSpawn=0; state.spawnIdx=0;
    state.lane=1.0; state.desiredLane=1.0; state.laneV=0;
    state.entities.length=0; state.particles.length=0; links.length=0;
    state.energy=60; state.shake=0; state.surgeMs=0; state.nextSurge=CONFIG.GAME.surgeEvery;
    state.combo=0; state.comboT=0; state.nearMissCount=0;
    state.grace=CONFIG.GAME.graceMs; state.stage=1; state.lastSlipT=0; $('#stageLabel').textContent='Stage 1';
    $('#playerName').hidden = true;
    $('#uiHUD').hidden=false; $('#uiStart').hidden=true; $('#uiOver').hidden=true; $('#touchCtrl').hidden=false;
    $('#score').textContent='0'; $('#best').textContent=String(state.best);
    lastGaugePct=-1; drawGauge();
    drawEnergyBar();
  }
  function startFromUI(){
    const name = $('#name').value.trim().slice(0,16);
    state.name  = name;
    if (name) localStorage.setItem('hrfz_last_name', name);  
    /* NEW: hi·ªÉn th·ªã pill t√™n */
    $('#playerName').textContent = name || 'Kh√¥ng T√™n';
    $('#playerName').hidden      = !name;
  
    resetGame();
    loop();
    if ($('#optBgm').checked) AudioKit.startBgm(); else AudioKit.stopBgm();
  }


  $('#btnPlay').addEventListener('click', startFromUI);
  $('#btnRetry').addEventListener('click', startFromUI);
  $('#btnShare').addEventListener('click', async ()=>{
    const text=`T√¥i ƒë·∫°t ${Math.floor(state.score)} ƒëi·ªÉm ·ªü #HyperRushFreeze ‚Äî b·∫°n d√°m v∆∞·ª£t kh√¥ng?`;
    try{
      if (navigator.share) await navigator.share({title:'HyperRush Freeze', text, url:location.href});
      else { await navigator.clipboard.writeText(`${text}\n${location.href}`); alert('ƒê√£ copy li√™n k·∫øt!'); }
    }catch(_){}
  });
  $('#btnPoster').addEventListener('click', ()=>makePoster(true));
  $('#btnSave').addEventListener('click', ()=>makePoster(false));
  $('#btnL').addEventListener('click', ()=>stepLane(-1));
  $('#btnR').addEventListener('click', ()=>stepLane(1));
  $('#best').textContent = String(state.best);

  const lastName=localStorage.getItem('hrfz_last_name'); if (lastName) $('#name').value=lastName;

  // ui.js ‚Äì s·ª± ki·ªán n√∫t ‚ÄúTop 10‚Äù
  $('#btnTop').addEventListener('click', async () => {
    $('#topPanel').hidden = false;
    $('#topList').textContent = 'ƒêang t·∫£i‚Ä¶';
  
    try {
      const data  = await fetchTop();              // back-end tr·∫£ v·ªÅ {items:[‚Ä¶]}
      const items = Array.isArray(data) ? data     // n·∫øu backend ƒë√£ thay ƒë·ªïi
                                        : (data.items || []);
  
      $('#topList').innerHTML = items.length
        ? '<ol>' + items.map(x =>
            `<li>${x.name || 'NoName'} ‚Äî <b>${x.score}</b></li>`).join('') +
          '</ol>'
        : 'Ch∆∞a c√≥ d·ªØ li·ªáu.';
    } catch (err) {
      console.error(err);
      $('#topList').textContent = 'L·ªói t·∫£i b·∫£ng ƒëi·ªÉm.';
    }
  });

  $('#btnCloseTop').addEventListener('click', ()=>$('#topPanel').hidden=true);

  $('#btnTut').addEventListener('click', ()=>$('#tut').hidden=false);
  $('#btnOkTut').addEventListener('click', ()=>{ $('#tut').hidden=true; localStorage.setItem('hrfz_seen_tut','1'); });

  if (!localStorage.getItem('hrfz_seen_tut')) $('#tut').hidden=false;

  const ps = new URLSearchParams(location.search);
  if (ps.get('autoplay')==='1'){ setTimeout(startFromUI, 300); }

  if ('serviceWorker' in navigator) { addEventListener('load', ()=>navigator.serviceWorker.register('./sw.js').catch(()=>{})); }
  new ResizeObserver(()=>fitCanvas(canvas)).observe($('#wrap'));

  // Pause/Resume
  let last=now(), acc=0;
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden){
      state.holding=false; state._autoResume=state.running; state.running=false;
    } else if (state._autoResume){
      state.running=true; state._autoResume=false; last=now(); loop();
    }
  }, {passive:true});

  /* =============== Main Loop (adaptive FPS & DPR + tier) =============== */
  function draw(){
    const lite = (state.gfxTier===2) && ((state.frame++ & 1)===1);
    ctx.clearRect(0,0,W,H);
    ctx.save();
    if (state.shake>0 && !mqlReduce.matches){
      ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
    }
  
    if (!lite) drawRoad();
  
    // 1) Entities tr∆∞·ªõc
    for (const e of state.entities)
      (e.type==='ob') ? drawObstacle(laneX(e.lane), e.y) : drawOrb(laneX(e.lane), e.y);
  
    // 2) ‚ú® Links sau ƒë·ªÉ lu√¥n n·∫±m tr√™n c√°c kh·ªëi
    drawLinks();
  
    // 3) Player + particles
    drawPlayer(laneX(state.lane), state.playerY);
  
    if (state.gfxTier===2){
      for (let i=0;i<state.particles.length;i+=2){
        const p=state.particles[i]; const k=1-(p.age/p.life); if (k<=0) continue;
        ctx.globalAlpha=Math.max(0,k); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    } else {
      for (const p of state.particles){
        const k=1-(p.age/p.life); ctx.globalAlpha=Math.max(0,k);
        ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    }
  
    ctx.restore();
    drawGauge();
  }


  function loop(){
    if (!state.running) return;
    const t=now(); let dt=Math.min(34,t-last); last=t; acc+=dt;

    const fps = 1000/Math.max(1, dt);
    state.fpsEMA = state.fpsEMA*0.9 + fps*0.1;

    if (state.fpsEMA < 52) state.lowSpec = true;
    autoTune();

    while (acc>=16){ update(16); acc-=16; }
    draw(); requestAnimationFrame(loop);
  }

  /* =============== Poster =============== */
  async function makePoster(onlyPreview){
    const off=document.createElement('canvas'); const s=720; off.width=s; off.height=1280;
    const c=off.getContext('2d');
    const g=c.createLinearGradient(0,0,0,1280); g.addColorStop(0,'#0a0f1c'); g.addColorStop(1,'#0b1220'); c.fillStyle=g; c.fillRect(0,0,off.width,off.height);
    c.fillStyle='#22d3ee'; c.font='700 44px system-ui,Segoe UI,Roboto'; c.fillText('HyperRush ‚Äî Freeze', 36, 80);
    c.fillStyle='#e5f0ff'; c.font='700 120px system-ui,Segoe UI,Roboto'; c.fillText(`${Math.floor(state.score)}`, 36, 220);
    c.fillStyle='#93a4c3'; c.font='400 28px system-ui,Segoe UI,Roboto';
    c.fillText(`Best ${state.best} ‚Ä¢ Stage ${state.stage} ‚Ä¢ Near-miss ${state.nearMissCount}`, 36, 260);
    c.drawImage(canvas, 0,0,canvas.width,canvas.height, 36, 300, 648, 1036);
    const blob=await new Promise(r=>off.toBlob(r,'image/png',0.92));
    const file=new File([blob],'hyperrush_poster.png',{type:'image/png'});
    if (onlyPreview){
      const url=URL.createObjectURL(blob); open(url,'_blank'); setTimeout(()=>URL.revokeObjectURL(url),60000);
    } else {
      if (navigator.canShare && navigator.canShare({files:[file]})){
        try{ await navigator.share({files:[file],title:'HyperRush Poster'}); return; }catch(_){}
      }
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hyperrush_poster.png'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),60000);
    }
  }

  $('#touchCtrl').hidden = !('ontouchstart' in window);
  $('#optBgm').addEventListener('change', e=>{ if(e.target.checked) AudioKit.startBgm(); else AudioKit.stopBgm(); }, {passive:true});

})();</script>
</body>
</html>
