<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,interactive-widget=resizes-content">

  <meta name="theme-color" content="#0ea5e9">
  <meta name="robots" content="noindex,nofollow">
  <title>HyperRush — Freeze Edition</title>
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root{ --brand:#0ea5e9; --bg:#0b1220; --card:#0f172a; --text:#e5f0ff; --muted:#93a4c3; --ok:#16a34a; --bad:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0b1326 60%,#0b1220);color:var(--text);
         font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
         touch-action:manipulation;-webkit-tap-highlight-color:transparent;outline:0;
         min-height:100dvh;}
    
    /* FULLSCREEN: bỏ max-width, bám theo viewport thực */
    #wrap{
      position:fixed; inset:0;            /* chiếm trọn màn hình */
      width:100vw; height:100dvh;
      margin:0; max-width:none;           /* << bỏ 480px gây co nhỏ */
      overflow:hidden;
    }
    
    /* đã có rồi nhưng để chắc chắn */
    #game{display:block;width:100%;height:100%;background:
      radial-gradient(ellipse at 50% -10%,rgba(14,165,233,.25),transparent 55%),
      linear-gradient(180deg,#0a0f1c,#0b1220)}
    
    /* fallback cho máy cũ không hỗ trợ dvh */
    @supports not (height: 100dvh) {
      #wrap{ height:100vh; }
    }

    .ui{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
    .card{background:rgba(15,23,42,.82);backdrop-filter:blur(8px);border:1px solid rgba(148,163,184,.15);border-radius:16px;padding:18px 16px;max-width:420px;width:100%;box-shadow:0 20px 50px rgba(14,165,233,.08)}
    h1{font-size:22px;margin:0 0 4px;letter-spacing:.2px}
    p{margin:4px 0 10px;color:var(--muted);font-size:14px}
    .row{display:flex;gap:10px;margin-top:10px;align-items:center}
    button{flex:1;border:0;border-radius:12px;background:var(--brand);color:#fff;font-weight:700;padding:12px 14px;font-size:16px;box-shadow:0 10px 30px rgba(14,165,233,.25);cursor:pointer}
    button:active{transform:translateY(1px)}
    input[type="text"]{flex:1;background:#0b1220;border:1px solid rgba(148,163,184,.2);border-radius:12px;color:#fff;padding:10px 12px;outline:none}
    label.switch{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;font-weight:700;text-shadow:0 2px 10px rgba(0,0,0,.4);z-index:40}
    .pill{background:rgba(2,6,23,.55);border:1px solid rgba(148,163,184,.15);padding:8px 12px;border-radius:999px}
    .hint{font-size:12px;color:var(--muted)}
    .small{font-size:12px}
    .center{text-align:center}
    .mt8{margin-top:8px}
    .row-small{display:flex;gap:8px;margin-top:8px}

    #gauge{position:absolute;right:8px;top:46px;width:64px;height:64px;border-radius:999px;background:rgba(2,6,23,.45);border:1px solid rgba(148,163,184,.15);display:flex;align-items:center;justify-content:center;z-index:50;pointer-events:none}
    #gcv{width:56px;height:56px;display:block}
    #toast{position:absolute;left:50%;top:58px;transform:translateX(-50%);padding:6px 10px;background:rgba(250,250,250,.12);border:1px solid rgba(255,255,255,.2);border-radius:999px;font-size:12px;opacity:0;transition:opacity .18s, transform .18s;z-index:45}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
    [hidden]{display:none !important;}

    #game{ touch-action:none; }
    html,body,#wrap{ overscroll-behavior:none; }

    .touch-ctrl{ position:absolute;left:0;right:0;bottom:18px; display:flex;justify-content:space-between;padding:0 18px;pointer-events:none;z-index:35 }
    .touch-ctrl button{ width:64px;height:64px;border-radius:999px;border:0;background:rgba(2,6,23,.35);color:#fff;font-size:22px;border:1px solid rgba(148,163,184,.18);box-shadow:0 10px 20px rgba(0,0,0,.2); pointer-events:auto }

    #tut{position:absolute;inset:0;background:rgba(2,6,23,.7);display:flex;align-items:center;justify-content:center;z-index:60}
    #tut .card{max-width:460px}

    @media (prefers-reduced-motion: reduce){
      #toast{transition:none}
    }
    :root{
      /* sẽ được JS cập nhật mỗi lần fitCanvas() chạy */
      --cw: 360px; /* canvas width hiển thị */
      --ch: 640px; /* canvas height hiển thị */
    }
    
    /* #wrap chiếm trọn màn hình + căn giữa canvas ở PC */
    #wrap{
      position: fixed; inset: 0;
      width: 100vw; height: 100dvh;           /* full màn hình thực trên mobile */
      margin: 0; max-width: none; overflow: hidden;
      display: grid; place-items: center;      /* canvas vào đúng giữa */
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        calc(env(safe-area-inset-bottom) + 8px)
        env(safe-area-inset-left);
    }
    
    /* Canvas có bo góc + bóng nhẹ cho PC */
    #game{ border-radius: 14px; box-shadow: 0 28px 80px rgba(14,165,233,.12); }
    
    /* HUD bám theo bề rộng canvas (đẹp trên PC, không lệch trái) */
    .hud{
      position: absolute;
      top: max(8px, env(safe-area-inset-top));
      left: 50%; transform: translateX(-50%);
      width: var(--cw);                         /* căn theo canvas */
      padding: 8px 12px;
    }
    
    /* Gauge bám mép phải của canvas (không dạt ra rìa màn hình) */
    #gauge{
      position: absolute;
      top: calc(max(46px, env(safe-area-inset-top) + 38px));
      right: calc(50% - var(--cw)/2 + 8px);     /* mép phải canvas + 8px */
    }
    
    /* Toast giữ theo tâm canvas */
    #toast{
      left: 50%; transform: translateX(-50%);
    }
    
    /* Cụm nút chạm bám đáy canvas + safe-area */
    .touch-ctrl{
      position: absolute; left: 50%; transform: translateX(-50%);
      width: var(--cw);
      bottom: max(18px, env(safe-area-inset-bottom));
      padding: 0 18px;
    }
    
    /* Tăng cỡ chữ HUD theo màn lớn nhưng không quá to */
    .pill{ font-size: clamp(12px, 1.2vw, 16px); }
    
    /* PC lớn: bo góc & bóng đậm hơn chút */
    @media (min-width: 900px){
      #game{ border-radius: 18px; }
    }

  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640" aria-label="HyperRush Freeze"></canvas>

    <div id="uiStart" class="ui" role="dialog" aria-modal="true">
      <div class="card">
        <h1>HyperRush — Freeze</h1>
        <p>Giữ chạm để <b>Freeze</b>. Vuốt ngang để <b>kéo</b> nhân vật – không nhảy bậc.</p>
        <div class="row">
          <input id="name" type="text" maxlength="16" placeholder="Tên hiển thị (tuỳ chọn)">
          <button id="btnPlay">Chơi ngay</button>
        </div>
        <div class="row-small">
          <label class="switch"><input id="optTilt" type="checkbox"> Nghiêng máy để lái</label>
          <label class="switch"><input id="optBgm" type="checkbox"> Nhạc nền</label>
        </div>
        <p class="hint">PC: A/D hoặc ← →; Space = Freeze • Mobile: vuốt liên tục, chạm trái/phải để đổi làn nhanh.</p>
        <div class="small">Bản đồ thay đổi mỗi ngày. Cố gắng vượt 2.500!</div>
        <div class="row-small">
          <button id="btnTop">Top 10 ngày</button>
          <button id="btnTut">Hướng dẫn</button>
        </div>
      </div>
    </div>

    <div id="uiHUD" class="hud" hidden>
      <div class="pill">Điểm: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill small" id="stageLabel">Stage 1</div>
    </div>

    <div id="uiOver" class="ui" hidden role="dialog" aria-modal="true">
      <div class="card center">
        <h1>Thua rồi!</h1>
        <p>Điểm: <b id="finalScore">0</b> • Best: <b id="best2">0</b></p>
        <div id="overMsg" class="hint mt8"></div>
        <div class="row mt8">
          <button id="btnRetry">Chơi lại</button>
          <button id="btnShare">Chia sẻ</button>
        </div>
        <div class="row mt8">
          <button id="btnPoster">Tạo ảnh Poster</button>
          <button id="btnSave">Tải Poster</button>
        </div>
      </div>
    </div>

    <div id="tut" hidden>
      <div class="card">
        <h1>Hướng dẫn nhanh (5s)</h1>
        <p>• Giữ tay để <b>làm chậm</b> thời gian (Freeze).<br>
           • Vuốt <b>mượt</b> đổi làn — không nhảy bậc. <br>
           • Sượt chướng ngại <b>gần</b> sẽ được cộng năng lượng & combo. <br>
           • Orb xanh tăng điểm + năng lượng. <br>
           • Mỗi 300 điểm có <b>Stage</b> mới, cửa hẹp 3s.</p>
        <div class="row"><button id="btnOkTut">Hiểu rồi</button></div>
      </div>
    </div>

    <div id="gauge" aria-label="Freeze energy"><canvas id="gcv" width="96" height="96"></canvas></div>
    <div id="toast">NEAR-MISS +6%</div>

    <div id="touchCtrl" class="touch-ctrl" hidden>
      <button id="btnL">◀</button>
      <button id="btnR">▶</button>
    </div>

    <div id="topPanel" class="ui" hidden>
      <div class="card">
        <h1>Bảng xếp hạng ngày</h1>
        <div id="topList" class="small">Đang tải…</div>
        <div class="row mt8"><button id="btnCloseTop">Đóng</button></div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /* =============== Config =============== */
  const CONFIG = {
    API_URL: 'https://script.google.com/macros/s/AKfycbznfw8rrffCKv0OObRRc8j6YHKir6dEwpLrG4eNn-Azc3xvg4_UrI3fbUoBRv6Dq-e1DQ/exec',
    AUDIO: { enabled: true, volume: 0.32, sfxUrl: '', bgmUrl: '' },
    PERF:  { dprMax: 1.35, maxEntities: 120, maxParticles: 180, minDpr: 0.85 },
    GAME: {
      lanes: 3, baseSpeed: 135, accel: 0.06,
      spawnEvery: 740, spawnAccel: 0.986,
      minSpawnEvery: 220, maxSpawnsPerFrame: 6,
      orbChance: 0.22, freezeRate: 0.28, regenPassive: 0.003,
      regenNear: 6, regenOrb: 10, freezeSlow: 0.25,
      minGapObPx: 148, minGapOrbPx: 118, maxSpawnAttempts: 3,
      surgeEvery: 300, surgeMs: 3000, graceMs: 1500
    }
  };
  const TIERS = {
    base:{ maxEntities:120, maxParticles:180, minSpawnEvery:220, cap:6,  roadStep:40,  dprAdj:0 },
    mid: { maxEntities:95,  maxParticles:90,  minSpawnEvery:280, cap:4,  roadStep:56,  dprAdj:-0.15 },
    low: { maxEntities:80,  maxParticles:60,  minSpawnEvery:320, cap:3,  roadStep:72,  dprAdj:-0.30 }
  };
  /* ===== Anti-exploit ===== */
  const ANTI = {
    campMs: 1800,         // >1.8s không đổi làn => coi là camping
    campCooldownMs: 1200, // giãn cách giữa 2 lần ép chặn
    corridorBand: 42,     // dải y (px) coi là cùng một hàng để phá "hành lang"
    spawnJitter: 18       // lệch y khi spawn để khỏi thẳng hàng
  };

  const LOW = (navigator.hardwareConcurrency && navigator.hardwareConcurrency<=4);
  if (LOW){ CONFIG.PERF.dprMax=1.2; CONFIG.PERF.maxParticles=140; }

  /* =============== Utils =============== */
  const $ = sel => document.querySelector(sel);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();
  const mqlReduce = matchMedia('(prefers-reduced-motion: reduce)');

  function vibrate(p){ try{ if(!mqlReduce.matches) navigator.vibrate && navigator.vibrate(p);}catch(_){ } }

  function getDeviceId(){
    const k='hrfz_device_id'; let id=localStorage.getItem(k);
    if(!id){ id=crypto.getRandomValues(new Uint32Array(4)).join('-'); localStorage.setItem(k,id); }
    return id;
  }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

  const BASE_W=360, BASE_H=640, MARGIN=40; let DPR=1, ROAD_STEP=40;

  function fitCanvas(canvas){
    const ratio = BASE_W / BASE_H;
  
    // Kích thước viewport "thực" (ẩn/hiện URL bar, bàn phím…)
    const w = Math.max(1, (window.visualViewport?.width || window.innerWidth));
    const h = Math.max(1, (window.visualViewport?.height || window.innerHeight));
  
    // Tính size canvas theo tỉ lệ 360x640
    let cw = w, ch = w / ratio;
    if (ch > h) { ch = h; cw = h * ratio; }
  
    // Style kích thước hiển thị
    canvas.style.width  = cw + 'px';
    canvas.style.height = ch + 'px';
  
    // Cập nhật biến CSS để HUD/gauge/nút bám theo đúng bề rộng canvas
    document.documentElement.style.setProperty('--cw', cw + 'px');
    document.documentElement.style.setProperty('--ch', ch + 'px');
  
    // DPR an toàn theo cấu hình hiệu năng
    const dprTarget = clamp((window.devicePixelRatio || 1), CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    DPR = dprTarget;
  
    // Kích thước buffer vẽ
    canvas.width  = Math.round(BASE_W * DPR);
    canvas.height = Math.round(BASE_H * DPR);
  
    // Scale hệ toạ độ về đơn vị logic (BASE_W x BASE_H)
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }



  function dailySeed(){
    const d=new Date(); const s=Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())>>>0;
    return s ^ (getDeviceId().split('-')[0]>>>0);
  }

  /* ====== Spawn table động ====== */
  function makeSpawnTable(base, accel, minMs, limit=4096){
    const out=[]; let v=base, i=0;
    while (i<limit && v>minMs){ out.push(v); v*=accel; i++; }
    out.push(minMs); return new Float32Array(out);
  }
  let SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  function rebuildSpawnTable(minMs){
    CONFIG.GAME.minSpawnEvery = minMs;
    SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  }

  /* ----- Hitbox & hình học ----- */
  const HIT = { P_W:30, P_H:30, OB_W:36, OB_H:36, NEAR_PAD:8 };
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return (Math.abs(ax - bx) <= (aw + bw) * 0.5) && (Math.abs(ay - by) <= (ah + bh) * 0.5);
  }
  function laneWidth(){ return (W - MARGIN*2)/CONFIG.GAME.lanes; }

  /* ====== Link cảnh báo giữa 2 làn ====== */
  const links = []; // {y, age, life, strong}
  function addLink(y, strong){
    if (links.length>24) links.shift();
    links.push({y, age:0, life:420, strong:!!strong});
  }

  /* =============== Audio =============== */
  const AudioKit = (function(){
    let ctx, master, sfxBuf=null, bgm=null, bgmGain=null;
    function ensure(){
      if (!CONFIG.AUDIO.enabled) return null;
      if (!ctx){ ctx=new (window.AudioContext||window.webkitAudioContext)(); master=ctx.createGain(); master.gain.value=CONFIG.AUDIO.volume; master.connect(ctx.destination); }
      return ctx;
    }
    async function load(url){ const c=ensure(); if(!c||!url) return null;
      try{ const r=await fetch(url); const a=await r.arrayBuffer(); return await c.decodeAudioData(a);}catch(_){return null;}
    }
    async function prepare(){ if(!ensure()) return; if(CONFIG.AUDIO.sfxUrl && !sfxBuf) sfxBuf=await load(CONFIG.AUDIO.sfxUrl); }
    function unlock(){ const c=ensure(); if(!c) return; if(c.state==='suspended') c.resume().catch(()=>{}); }
    function playBuf(buf,time=0,off=0,dur){ if(!buf) return; const c=ensure(); const src=c.createBufferSource(); src.buffer=buf; src.connect(master); if(dur) src.start(c.currentTime+time,off,dur); else src.start(c.currentTime+time,off); }
    const SPR={ move:[0.00,0.08], near:[0.10,0.10], orb:[0.22,0.16], freeze_on:[0.40,0.12], hit:[0.56,0.22], taunt:[0.80,0.20] };
    function tone(o){ const c=ensure(); if(!c) return; const osc=c.createOscillator(), g=c.createGain();
      osc.type=o.type||'sine'; osc.frequency.value=o.freq||440; if(o.detune) osc.detune.value=o.detune;
      g.gain.value=0; osc.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, d=o.decay||0.12, s=o.sustain||0.0001, r=o.release||0.08, v=o.gain||0.4;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(s,t+a+d); g.gain.linearRampToValueAtTime(0,t+a+d+r);
      osc.start(t); osc.stop(t+a+d+r+0.01);
    }
    function noise(o){ const c=ensure(); if(!c) return;
      const b=c.createBuffer(1, c.sampleRate*0.18, c.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1);
      const src=c.createBufferSource(); src.buffer=b; const g=c.createGain(); g.gain.value=0; src.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, r=o.release||0.14, v=o.gain||0.45;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(0,t+a+r);
      src.start(t); src.stop(t+a+r+0.01);
    }
    function sfx(n){
      if (sfxBuf && SPR[n]){ const [off,dur]=SPR[n]; return playBuf(sfxBuf,0,off,dur); }
      switch(n){ case 'move': tone({type:'square',freq:640,gain:0.18,decay:0.06,release:0.06}); break;
        case 'near': tone({type:'triangle',freq:880,gain:0.22,decay:0.04}); break;
        case 'orb':  tone({type:'sine',freq:520,gain:0.26,decay:0.05}); tone({type:'sine',freq:780,gain:0.20,decay:0.07}); break;
        case 'freeze_on': tone({type:'sawtooth',freq:300,gain:0.18,decay:0.08}); break;
        case 'hit':  noise({gain:0.6}); tone({type:'square',freq:140,gain:0.25,decay:0.09,release:0.2}); break;
        case 'taunt': tone({type:'triangle',freq:480,gain:0.16,decay:0.12}); break; }
    }
    async function startBgm(){ if(!CONFIG.AUDIO.bgmUrl) return; const c=ensure(); if(!c) return;
      if(!bgm){ const buf=await load(CONFIG.AUDIO.bgmUrl); if(!buf) return;
        const src=c.createBufferSource(); src.buffer=buf; src.loop=true; bgmGain=c.createGain(); bgmGain.gain.value=0; src.connect(bgmGain); bgmGain.connect(master); src.start();
        bgm=src; const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0.25,t+1.2); } }
    function stopBgm(){ if(bgmGain){ const c=ensure(); const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0,t+0.6); } }
    return {unlock,prepare,sfx,startBgm,stopBgm};
  })();

  /* =============== Backend =============== */
  async function postScore(payload) {
    if (!CONFIG.API_URL) return;
    try {
      await fetch(CONFIG.API_URL, {
        method:'POST', mode:'cors', headers:{'Content-Type':'text/plain'},
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined
      }).catch(()=>{});
    } catch (_){}
  }
  async function fetchTop(){
    if (!CONFIG.API_URL) throw 'No API';
    const url = CONFIG.API_URL + '?top=10';
    const r = await fetch(url, {mode:'cors', signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined});
    return await r.json();
  }

  /* =============== Game State =============== */
  const canvas = $('#game'); 
  const ctx = canvas.getContext('2d');
  fitCanvas(canvas);
  addEventListener('resize', () => fitCanvas(canvas));
  if (window.visualViewport){
    visualViewport.addEventListener('resize', () => fitCanvas(canvas));
    visualViewport.addEventListener('scroll',  () => fitCanvas(canvas)); // khi URL bar trượt
  }
  new ResizeObserver(() => fitCanvas(canvas)).observe($('#wrap'));

  
  const gcv = $('#gcv'); 
  const gctx = gcv.getContext('2d');


  let W=BASE_W, H=BASE_H;
  const state = {
    running:false, over:false, startedAt:0, playMs:0,
    name:'', score:0, best:Number(localStorage.getItem('hrfz_best')||0),
    rng: mulberry32(dailySeed()),
    speed: CONFIG.GAME.baseSpeed,
    lastSpawn: 0, spawnIdx: 0,
    lane: 1.0, desiredLane: 1.0, laneV:0,
    playerY: H-120,
    entities: [],
    energy: 60,
    holding:false,
    lastNearT: 0,
    shake: 0,
    particles: [],
    surgeMs: 0, nextSurge: CONFIG.GAME.surgeEvery,
    dragging:false, dragStartX:0, dragStartLane:1.0, hasDragged:false, dragStartT:0,
    combo:0, comboT:0,
    grace: CONFIG.GAME.graceMs,
    stage:1, lastStageAnnounce:0,
    nearMissCount:0,
    lowSpec:false, fpsEMA:60,
    gfxTier:0, _tierLockT:0, frame:0,
    lastSlipT:0,                 // <-- THÊM DẤU PHẨY Ở CUỐI DÒNG NÀY
    lastLaneChangeT: now(),      // lần gần nhất đổi làn nguyên
    _laneI: 1,                   // làn nguyên hiện tại (để so sánh)
    _antiCampT: 0,               // cooldown anti-camp

  };

  /* =============== Particles =============== */
  function spawnParticles(x,y,color,count=12,spd=1){
    const allow = Math.max(0, CONFIG.PERF.maxParticles - state.particles.length);
    count = Math.min(count, allow);
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      state.particles.push({ x,y, vx: Math.cos(a)*(1.2+Math.random()*2)*spd, vy: Math.sin(a)*(1.2+Math.random()*2)*spd,
        life: 420+Math.random()*260, age:0, color });
    }
  }

  /* =============== Input =============== */
  function stepLane(dir){
    const next = clamp(Math.round(state.desiredLane) + Math.sign(dir), 0, CONFIG.GAME.lanes-1);
    if (next!==Math.round(state.desiredLane)){ state.desiredLane = next; AudioKit.sfx('move'); }
  }
  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowleft'||k==='a') stepLane(-1);
    if (k==='arrowright'||k==='d') stepLane(1);
    if (k===' ') { state.holding = true; AudioKit.sfx('freeze_on'); }
  }, {passive:true});
  addEventListener('keyup', (e)=>{ if (e.key===' ') state.holding=false; }, {passive:true});

  const TAP_TIME_MAX=160;
  const DRAG_PX_THRESHOLD=10*(window.devicePixelRatio||1);

  canvas.addEventListener('pointerdown', async (e)=>{
    if (state.dragging) return;
    state.dragging=true; state.dragStartX=e.clientX; state.dragStartLane=state.desiredLane; state.dragStartT=now();
    state.hasDragged=false; canvas.setPointerCapture?.(e.pointerId);
    state.holding=true; await AudioKit.prepare(); AudioKit.unlock(); AudioKit.sfx('freeze_on'); e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (!state.dragging) return;
    const dx=e.clientX-state.dragStartX;
    if (Math.abs(dx)>DRAG_PX_THRESHOLD) state.hasDragged=true;
    const laneW=(W-MARGIN*2)/CONFIG.GAME.lanes;
    const cont=state.dragStartLane + dx/laneW;
    state.desiredLane=clamp(cont,0,CONFIG.GAME.lanes-1); e.preventDefault();
  }, {passive:false});
  function endPointer(e){
    if (!state.dragging) return;
    try{ canvas.releasePointerCapture?.(e.pointerId);}catch(_){}
    const dtTap=now()-(state.dragStartT||0);
    const dx=Math.abs((e.clientX||0)-(state.dragStartX||0));
    if (!state.hasDragged && dtTap<=TAP_TIME_MAX && dx<DRAG_PX_THRESHOLD){
      const r=canvas.getBoundingClientRect(); stepLane(e.clientX < r.left+r.width/2 ? -1 : 1);
    }
    state.dragging=false; state.holding=false; e.preventDefault();
  }
  canvas.addEventListener('pointerup', endPointer, {passive:false});
  canvas.addEventListener('pointercancel', endPointer, {passive:false});
  canvas.addEventListener('pointerleave', endPointer, {passive:false});

  $('#optTilt').addEventListener('change', async (e)=>{
    if (e.target.checked){
      try{
        if (typeof DeviceMotionEvent!=='undefined' && DeviceMotionEvent.requestPermission){
          const perm=await DeviceMotionEvent.requestPermission(); if (perm!=='granted') e.target.checked=false;
        }
      }catch(_){}
    }
  }, {passive:true});
  addEventListener('devicemotion', (ev)=>{
    if (!$('#optTilt').checked || !state.running) return;
    const ax = ev.accelerationIncludingGravity ? ev.accelerationIncludingGravity.x||0 : 0;
    const tilt=clamp(ax/6,-1,1);
    state.desiredLane=clamp(1+tilt,0,CONFIG.GAME.lanes-1);
  }, {passive:true});

  /* =============== Helpers =============== */
  function smoothLane(dt){
    const k=28, c=2*Math.sqrt(k), x=state.lane-state.desiredLane, a=-k*x - c*state.laneV, dtSec=dt/1000;
    state.laneV += a*dtSec; state.lane += state.laneV*dtSec; state.lane=clamp(state.lane,0,CONFIG.GAME.lanes-1);
  }
  function applyStages(){
    const s = Math.floor(state.score/CONFIG.GAME.surgeEvery)+1;
    if (s!==state.stage){
      state.stage=s; $('#stageLabel').textContent=`Stage ${state.stage}`;
      CONFIG.GAME.orbChance = clamp(0.22 - 0.01*(state.stage-1), 0.12, 0.22);
      CONFIG.GAME.minGapObPx = clamp(148 - 4*(state.stage-1), 120, 148);
      if (now()-state.lastStageAnnounce>2000){ toast(`Stage ${state.stage}!`); AudioKit.sfx('taunt'); }
      state.lastStageAnnounce=now();
    }
  }

  /* ====== Auto tune perf by FPS/Stage ====== */
  function applyTier(tierName){
    const t = TIERS[tierName];
    CONFIG.PERF.maxEntities = t.maxEntities;
    CONFIG.PERF.maxParticles = t.maxParticles;
    CONFIG.GAME.maxSpawnsPerFrame = t.cap;
    ROAD_STEP = t.roadStep;
    rebuildSpawnTable(t.minSpawnEvery);

    const newDpr = clamp(DPR + t.dprAdj, CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    if (Math.abs(newDpr - DPR) > 0.01){
      DPR = newDpr; fitCanvas(canvas);
    }
  }
  function autoTune(){
    if (now() - state._tierLockT < 1500) return;
    let target = 0;
    if (state.fpsEMA < 48 || state.stage >= 10) target = 1;
    if (state.fpsEMA < 42 || state.stage >= 12) target = 2;
    if (target !== state.gfxTier){
      state.gfxTier = target;
      applyTier(target===2 ? 'low' : target===1 ? 'mid' : 'base');
      state._tierLockT = now();
    }
  }

  /* =============== Update =============== */
  function update(dt) {
    const timeScale = state.holding && state.energy>0 ? CONFIG.GAME.freezeSlow : 1;
    const dtEff = dt * timeScale;

    if (state.grace>0) state.grace = Math.max(0, state.grace - dt);

    state.energy = state.holding && state.energy>0
      ? Math.max(0, state.energy - CONFIG.GAME.freezeRate * (dt/10))
      : Math.min(100, state.energy + CONFIG.GAME.regenPassive * (dt/10));

    state.speed += CONFIG.GAME.accel * dtEff/16.6;
    state.spawnIdx += dtEff/16.6;
    const spawnEvery = SPAWN_TABLE[Math.min(SPAWN_TABLE.length-1, state.spawnIdx|0)];
    state.score += dtEff * 0.06 * ( (state.lastNearT && (now()-state.lastNearT<1200)) ? 1.15 : 1 );
    $('#score').textContent = String(Math.floor(state.score));

    smoothLane(dtEff);
    /* Theo dõi đổi làn nguyên để reset đồng hồ camping */
    {
      const li = Math.round(state.desiredLane);
      if (li !== state._laneI) {
        state._laneI = li;
        state.lastLaneChangeT = now();
      }
    }

    applyStages();

    if (state.score >= state.nextSurge){ state.surgeMs = CONFIG.GAME.surgeMs; state.nextSurge += CONFIG.GAME.surgeEvery; toast('Cửa hẹp 3s!'); AudioKit.sfx('taunt'); }
    if (state.surgeMs>0) state.surgeMs = Math.max(0, state.surgeMs - dt);

    state.lastSpawn += dtEff;
    const spawnMul = state.surgeMs>0 ? 0.7 : 1;
    let spawned=0;
    const cap = Math.min(CONFIG.GAME.maxSpawnsPerFrame, CONFIG.PERF.maxEntities - state.entities.length);
    while (state.lastSpawn >= spawnEvery * spawnMul && spawned < cap) {
      state.lastSpawn -= spawnEvery * spawnMul;
      const times = 1 + (state.surgeMs>0 ? 1 : 0);
      for (let k=0;k<times;k++) trySpawn();
      spawned++;
    }
    if (spawned >= cap && state.lastSpawn > spawnEvery * spawnMul * 4) state.lastSpawn = 0;

    const px = laneX(state.lane), py = state.playerY;
    let eLnear = null, eRnear = null; // để vẽ link / bonus

    for (let i=state.entities.length-1;i>=0;i--) {
      const e = state.entities[i]; e.y += state.speed * dtEff/1000;
      const ex = laneX(e.lane), ey = e.y;

      if (e.type === 'orb') {
        const hitOrb = aabb(px, py, HIT.P_W, HIT.P_H, ex, ey, 22, 22);
        if (hitOrb) {
          state.score += 50; state.energy = Math.min(100, state.energy + CONFIG.GAME.regenOrb);
          state.entities.splice(i,1); flash(120); spawnParticles(px,py,'#38bdf8',12,1.1); AudioKit.sfx('orb'); vibrate(12);
          continue;
        }
      }

      if (e.type === 'ob') {
        const collided = (state.grace<=0) && aabb(px,py,HIT.P_W,HIT.P_H, ex,ey,HIT.OB_W,HIT.OB_H);
        const near = !collided && aabb(px,py,HIT.P_W+HIT.NEAR_PAD,HIT.P_H+HIT.NEAR_PAD, ex,ey,HIT.OB_W+HIT.NEAR_PAD,HIT.OB_H+HIT.NEAR_PAD);

        if (near && now()-state.lastNearT>240){
          state.nearMissCount++;
          if (now()-state.comboT<1200) state.combo++; else state.combo=1;
          state.comboT=now();
          const bonus = CONFIG.GAME.regenNear + Math.min(12, 2*Math.max(0, state.combo-1));
          state.energy = Math.min(100, state.energy + bonus);
          state.score += 4 * state.combo;
          toast(state.combo>1 ? `NEAR-MISS x${state.combo} +${bonus}%` : `NEAR-MISS +${CONFIG.GAME.regenNear}%`);
          state.lastNearT = now(); AudioKit.sfx('near'); vibrate(10);
        }

        if (collided) {
          if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
          boom(); spawnParticles(px,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
          return gameOver();
        }

        // Ghi nhận hai khối ở 2 làn kề nhau quanh người chơi để xử lý link/bonus
        const L = Math.floor(state.lane), R = L+1;
        if (e.lane===L && Math.abs(ey - py) < 34) eLnear = e;
        if (e.lane===R && Math.abs(ey - py) < 34) eRnear = e;
      }

      if (e.y > H+50) state.entities.splice(i,1);
    }

    /* ===== Công bằng “đi giữa 2 cột”: chỉ xử thua nếu khe thật sự KHÔNG LỌT ===== */
    if (state.grace <= 0) {
      const frac = state.lane - Math.floor(state.lane);
      if (frac > 0.44 && frac < 0.56) {
        const L = Math.floor(state.lane), R = L + 1;
        if (eLnear && eRnear) {
          const laneW = laneWidth();
          const gapBetweenInnerEdges = laneW - 2*(HIT.OB_W/2); // = laneW - 36
          const needToPass = HIT.P_W + 6; // người chơi + biên an toàn
          const impossible = gapBetweenInnerEdges < needToPass;

          // hiển thị chấm đỏ giữa 2 khối (đậm nếu impossible)
          addLink(py, impossible);

          if (impossible) {
            if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
            const pxMid = laneX(state.lane); boom(); spawnParticles(pxMid,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
            return gameOver();
          } else {
            // thưởng SLIP nhỏ khi lọt khe hẹp (cooldown)
            if (now()-state.lastSlipT>800) {
              state.lastSlipT = now();
              state.score += 12;
              state.energy = Math.min(100, state.energy + 4);
              toast('SLIP +12');
              AudioKit.sfx('near');
            }
          }
        }
      }
    }

    // Particles
    const pf = state.lowSpec ? 0.7 : 1;
    for (let i=state.particles.length-1;i>=0;i--){
      const p=state.particles[i]; p.age += dtEff; if (p.age>p.life){ state.particles.splice(i,1); continue; }
      p.x += p.vx * dtEff/16.6; p.y += p.vy * dtEff/16.6; p.vy += 0.002*dtEff*pf;
    }
    // links age
    for (let i=links.length-1;i>=0;i--){ links[i].age += dtEff; if (links[i].age>links[i].life) links.splice(i,1); }

    state.shake *= mqlReduce.matches ? 0.9 : 0.92;
  }
  /* Gợi ý làn để phá "hành lang" (2 kín, 1 trống trong cùng dải y) */
  function corridorSuggest(y){
    const occ = new Array(CONFIG.GAME.lanes).fill(false);
    for (const e of state.entities){
      if (e.type !== 'ob') continue;
      if (Math.abs(e.y - y) <= ANTI.corridorBand) occ[e.lane] = true;
    }
    let empty = -1, filled = 0;
    for (let i=0;i<occ.length;i++){
      if (occ[i]) filled++; else empty = i;
    }
    return (filled === CONFIG.GAME.lanes - 1) ? empty : -1; // chỉ còn đúng 1 làn trống
  }

  function trySpawn(){
    if (state.entities.length >= CONFIG.PERF.maxEntities) return;
  
    const early = (state.score < 80);
    const type  = (state.rng() < (early ? 0.4 : CONFIG.GAME.orbChance)) ? 'orb' : 'ob';
    if (early && type === 'ob') return;
  
    // lane ngẫu nhiên trước
    let lane  = Math.floor(state.rng() * CONFIG.GAME.lanes);
    let tries = 0;
  
    /* 1) Anti-camping: đứng một làn quá lâu => ưu tiên chặn đúng làn người chơi (có cooldown) */
    if (type === 'ob'
        && (now() - state.lastLaneChangeT > ANTI.campMs)
        && (now() - state._antiCampT   > ANTI.campCooldownMs)) {
      lane = Math.round(state.lane);
      state._antiCampT = now();
    }
  
    /* 2) Đảm bảo khoảng cách dọc + 3) Jitter y để khử "lưới thẳng hàng"
          4) Phá "hành lang" nếu chỉ còn 1 làn trống trong cùng dải y */
    do {
      let lastY = null;
      for (let i = state.entities.length - 1; i >= 0; i--) {
        const e = state.entities[i];
        if (e.lane === lane && e.type === type) { lastY = e.y; break; }
      }
      const need = (type === 'ob' ? CONFIG.GAME.minGapObPx : CONFIG.GAME.minGapOrbPx);
  
      if (lastY === null || (lastY + 40) >= need) {
        // Phá "hành lang" (chỉ áp dụng cho obstacle)
        if (type === 'ob') {
          const sug = corridorSuggest(-40);
          if (sug !== -1) lane = sug;
        }
        // spawn với jitter y để tránh thẳng hàng
        const jitter = Math.floor(state.rng() * ANTI.spawnJitter);
        state.entities.push({ type, lane, y: -40 - jitter });
        return;
      }
      lane = (lane + 1) % CONFIG.GAME.lanes;
    } while (++tries < CONFIG.GAME.maxSpawnAttempts);
  }


  /* =============== Render =============== */
  function laneX(lane){
    const roadW=W - MARGIN*2; const laneW = roadW/CONFIG.GAME.lanes;
    return Math.round(MARGIN + laneW*(0.5 + lane));
  }

  const GRAD={};
  function ensureGradients(){
    if (!GRAD.player){
      GRAD.player = ctx.createLinearGradient(-16,-16,16,16);
      GRAD.player.addColorStop(0,'#22d3ee'); GRAD.player.addColorStop(1,'#0ea5e9');
      GRAD.ob = ctx.createLinearGradient(0,-18,0,18);
      GRAD.ob.addColorStop(0,'#c64040'); GRAD.ob.addColorStop(1,'#9f2c2c');
    }
  }

  function drawRoad(){
    const roadW=W - MARGIN*2;
    ctx.save();
    // vạch dọc theo làn
    ctx.strokeStyle='rgba(148,163,184,0.15)'; ctx.lineWidth=2;
    for (let i=1;i<CONFIG.GAME.lanes;i++){ const x=MARGIN+roadW/CONFIG.GAME.lanes*i; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    // vạch ngang chạy
    const mult = state.surgeMs>0 ? 1.7 : 1;
    const offset = ((performance.now() * (state.holding && state.energy>0 ? 0.25 : 1)*mult)/20) % ROAD_STEP;
    ctx.strokeStyle='rgba(14,165,233,0.25)'; ctx.lineWidth=4;
    for (let y=-offset; y<H; y+=ROAD_STEP){ ctx.beginPath(); ctx.moveTo(MARGIN+8,y); ctx.lineTo(W-MARGIN-8,y); ctx.stroke(); }
    ctx.restore();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }
  function drawPlayer(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(0,18,20,8,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.player; roundRect(-16,-16,32,32,8,true,false);
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(0,-8); ctx.lineTo(8,0); ctx.lineTo(0,8); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
  function drawObstacle(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.28)'; ctx.beginPath(); ctx.ellipse(0,16,16,6,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.ob; roundRect(-18,-18,36,36,8,true,false);
    ctx.strokeStyle='rgba(0,0,0,.40)'; ctx.lineWidth=1.5; roundRect(-18,-18,36,36,8,false,true);
    ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-14,-12); ctx.lineTo(14,-12); ctx.stroke();
    ctx.restore();
  }
  function drawOrb(x,y){
    ctx.save(); ctx.translate(x,y);
    const r=10+Math.sin(performance.now()/120 + x)*2;
    const g=ctx.createRadialGradient(0,0,2,0,0,r);
    g.addColorStop(0,'rgba(255,255,255,0.85)');
    g.addColorStop(1,'rgba(56,189,248,0.9)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  /* ===== Vẽ chấm đỏ nối giữa 2 khối ===== */
  function drawLinks(){
    const lw = HIT.OB_W/2, xStep = 14;
    for (const L of links){
      const lifeK = Math.max(0, 1 - L.age/L.life);
      const alpha = (L.strong ? 0.55 : 0.28) * lifeK;
      const Llane = Math.floor(state.lane); // vị trí lane hiện tại chỉ để lấy x
      const x1 = laneX(0) + (laneWidth()*Math.floor(state.lane)); // không dùng lane hiện tại; ta dựng chung cho mọi cặp
      // vẽ cho mọi cặp kề nhau
      for (let k=0; k<CONFIG.GAME.lanes-1; k++){
        const xa = laneX(k) + lw, xb = laneX(k+1) - lw;
        ctx.globalAlpha = alpha;
        for (let x=xa; x<=xb; x+=xStep){
          ctx.fillStyle = L.strong ? 'rgba(239,68,68,1)' : 'rgba(239,68,68,1)';
          ctx.beginPath(); ctx.arc(x, L.y, 2.2, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    }
  }

  /* =============== FX / Gauge / Toast =============== */
  let flashT=0, boomT=0;
  function flash(ms){ if (!mqlReduce.matches){ flashT=now()+ms; } }
  function boom(){ boomT=now()+250; state.shake = mqlReduce.matches ? 0 : 10; }
  const origFill = ctx.fillStyle;
  const _draw = draw; draw = function(){ _draw(); postFX(); };
  function postFX(){
    const t=now();
    if (flashT>t){ ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(0,0,W,H); ctx.fillStyle=origFill; }
    if (boomT>t){ const k=(boomT-t)/250; ctx.save(); ctx.translate(W/2,H/2); ctx.rotate((1-k)*0.4); ctx.scale(1+(1-k)*0.05,1+(1-k)*0.05); ctx.restore(); }
  }

  let lastGaugePct=-1;
  function drawGauge(){
    const pct = Math.floor(clamp(state.energy,0,100));
    if (pct === lastGaugePct) return; lastGaugePct=pct;
    const c=gctx; const w=gcv.width, h=gcv.height; c.clearRect(0,0,w,h);
    c.save(); c.translate(w/2,h/2);
    c.strokeStyle='rgba(148,163,184,.22)'; c.lineWidth=10; c.beginPath(); c.arc(0,0,26,0,Math.PI*2); c.stroke();
    const end = -Math.PI/2 + (pct/100)*2*Math.PI;
    const grad = c.createLinearGradient(-30,-30,30,30); grad.addColorStop(0,'#22d3ee'); grad.addColorStop(1,'#0ea5e9');
    c.strokeStyle=grad; c.lineWidth=10; c.lineCap='round'; c.beginPath(); c.arc(0,0,26,-Math.PI/2, end); c.stroke();
    c.fillStyle='rgba(255,255,255,.9)'; c.beginPath(); c.moveTo(-5,0); c.lineTo(0,-5); c.lineTo(5,0); c.lineTo(0,5); c.closePath(); c.fill();
    c.restore();
  }
  function toast(txt){
    const el=$('#toast'); el.textContent=txt; el.classList.add('show');
    clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'),760);
  }

  /* =============== UI & Poster =============== */
  function gameOver(){
    state.running=false; state.over=true;
    state.playMs += (now()-state.startedAt);
    $('#uiHUD').hidden=true; $('#uiOver').hidden=false; $('#touchCtrl').hidden=true;
    $('#finalScore').textContent = Math.floor(state.score);
    $('#best2').textContent = state.best;
    const s=Math.floor(state.score), next=Math.ceil(s/100)*100, diff=next-s;
    $('#overMsg').textContent = (s>0 && diff>0 && diff<=12) ? `Thiếu ${diff} điểm nữa là chạm ${next}!`
      : (s>state.best ? 'Kỷ lục mới! Lần sau vượt 2.500 nhé.' : 'Gần thôi, thêm chút “sượt nhẹ” là qua!');

    const payload={ deviceId:getDeviceId(), name:String(state.name||'').slice(0,16),
      score:Math.max(0,Math.floor(state.score)), tz:Intl.DateTimeFormat().resolvedOptions().timeZone||'UTC',
      ua:navigator.userAgent, seed:dailySeed(), playMs:Math.floor(state.playMs), near:state.nearMissCount,
      clientProof: crypto.subtle ? 'sha256' : '' };
    try{
      if (crypto && crypto.subtle){
        const enc=new TextEncoder().encode(payload.deviceId+'|'+payload.score+'|'+payload.seed+'|'+payload.playMs+'|'+payload.near);
        crypto.subtle.digest('SHA-256', enc).then(buf=>{
          payload.clientProof=Array.from(new Uint8Array(buf)).map(x=>x.toString(16).padStart(2,'0')).join('');
          postScore(payload);
        }).catch(()=>postScore(payload));
      } else postScore(payload);
    }catch(_){ postScore(payload); }
  }

  function resetGame(){
    state.running=true; state.over=false; state.startedAt=now(); state.playMs=0;
    state.score=0; state.speed=CONFIG.GAME.baseSpeed;
    state.lastSpawn=0; state.spawnIdx=0;
    state.lane=1.0; state.desiredLane=1.0; state.laneV=0;
    state.entities.length=0; state.particles.length=0; links.length=0;
    state.energy=60; state.shake=0; state.surgeMs=0; state.nextSurge=CONFIG.GAME.surgeEvery;
    state.combo=0; state.comboT=0; state.nearMissCount=0;
    state.grace=CONFIG.GAME.graceMs; state.stage=1; state.lastSlipT=0; $('#stageLabel').textContent='Stage 1';
    $('#uiHUD').hidden=false; $('#uiStart').hidden=true; $('#uiOver').hidden=true; $('#touchCtrl').hidden=false;
    $('#score').textContent='0'; $('#best').textContent=String(state.best);
    lastGaugePct=-1; drawGauge();
  }
  function startFromUI(){
    const name=$('#name').value.trim().slice(0,16);
    state.name=name; if(name) localStorage.setItem('hrfz_last_name', name);
    resetGame(); loop();
    if ($('#optBgm').checked) AudioKit.startBgm(); else AudioKit.stopBgm();
  }

  $('#btnPlay').addEventListener('click', startFromUI);
  $('#btnRetry').addEventListener('click', startFromUI);
  $('#btnShare').addEventListener('click', async ()=>{
    const text=`Tôi đạt ${Math.floor(state.score)} điểm ở #HyperRushFreeze — bạn dám vượt không?`;
    try{
      if (navigator.share) await navigator.share({title:'HyperRush Freeze', text, url:location.href});
      else { await navigator.clipboard.writeText(`${text}\n${location.href}`); alert('Đã copy liên kết!'); }
    }catch(_){}
  });
  $('#btnPoster').addEventListener('click', ()=>makePoster(true));
  $('#btnSave').addEventListener('click', ()=>makePoster(false));
  $('#btnL').addEventListener('click', ()=>stepLane(-1));
  $('#btnR').addEventListener('click', ()=>stepLane(1));
  $('#best').textContent = String(state.best);

  const lastName=localStorage.getItem('hrfz_last_name'); if (lastName) $('#name').value=lastName;

  $('#btnTop').addEventListener('click', async ()=>{
    $('#topPanel').hidden=false; $('#topList').textContent='Đang tải…';
    try{
      const data=await fetchTop();
      $('#topList').innerHTML = data && Array.isArray(data)
        ? '<ol>' + data.map(x=>`<li>${x.name||'NoName'} — <b>${x.score}</b></li>`).join('') + '</ol>'
        : 'Không có dữ liệu.';
    }catch(_){ $('#topList').textContent='Không lấy được dữ liệu.'; }
  });
  $('#btnCloseTop').addEventListener('click', ()=>$('#topPanel').hidden=true);

  $('#btnTut').addEventListener('click', ()=>$('#tut').hidden=false);
  $('#btnOkTut').addEventListener('click', ()=>{ $('#tut').hidden=true; localStorage.setItem('hrfz_seen_tut','1'); });

  if (!localStorage.getItem('hrfz_seen_tut')) $('#tut').hidden=false;

  const ps = new URLSearchParams(location.search);
  if (ps.get('autoplay')==='1'){ setTimeout(startFromUI, 300); }

  if ('serviceWorker' in navigator) { addEventListener('load', ()=>navigator.serviceWorker.register('./sw.js').catch(()=>{})); }
  new ResizeObserver(()=>fitCanvas(canvas)).observe($('#wrap'));

  // Pause/Resume
  let last=now(), acc=0;
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden){
      state.holding=false; state._autoResume=state.running; state.running=false;
    } else if (state._autoResume){
      state.running=true; state._autoResume=false; last=now(); loop();
    }
  }, {passive:true});

  /* =============== Main Loop (adaptive FPS & DPR + tier) =============== */
  function draw(){
    const lite = (state.gfxTier===2) && ((state.frame++ & 1)===1);
    ctx.clearRect(0,0,W,H);
    ctx.save();
    if (state.shake>0 && !mqlReduce.matches){ ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake); }
    if (!lite) drawRoad();
    drawLinks();
    for (const e of state.entities) (e.type==='ob') ? drawObstacle(laneX(e.lane), e.y) : drawOrb(laneX(e.lane), e.y);
    drawPlayer(laneX(state.lane), state.playerY);
    if (state.gfxTier===2){
      for (let i=0;i<state.particles.length;i+=2){ const p=state.particles[i]; const k=1-(p.age/p.life); if (k<=0) continue; ctx.globalAlpha=Math.max(0,k); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill(); }
      ctx.globalAlpha=1;
    } else {
      for (const p of state.particles){ const k=1-(p.age/p.life); ctx.globalAlpha=Math.max(0,k); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill(); }
      ctx.globalAlpha=1;
    }
    ctx.restore();
    drawGauge();
  }

  function loop(){
    if (!state.running) return;
    const t=now(); let dt=Math.min(34,t-last); last=t; acc+=dt;

    const fps = 1000/Math.max(1, dt);
    state.fpsEMA = state.fpsEMA*0.9 + fps*0.1;

    if (state.fpsEMA < 52) state.lowSpec = true;
    autoTune();

    while (acc>=16){ update(16); acc-=16; }
    draw(); requestAnimationFrame(loop);
  }

  /* =============== Poster =============== */
  async function makePoster(onlyPreview){
    const off=document.createElement('canvas'); const s=720; off.width=s; off.height=1280;
    const c=off.getContext('2d');
    const g=c.createLinearGradient(0,0,0,1280); g.addColorStop(0,'#0a0f1c'); g.addColorStop(1,'#0b1220'); c.fillStyle=g; c.fillRect(0,0,off.width,off.height);
    c.fillStyle='#22d3ee'; c.font='700 44px system-ui,Segoe UI,Roboto'; c.fillText('HyperRush — Freeze', 36, 80);
    c.fillStyle='#e5f0ff'; c.font='700 120px system-ui,Segoe UI,Roboto'; c.fillText(`${Math.floor(state.score)}`, 36, 220);
    c.fillStyle='#93a4c3'; c.font='400 28px system-ui,Segoe UI,Roboto';
    c.fillText(`Best ${state.best} • Stage ${state.stage} • Near-miss ${state.nearMissCount}`, 36, 260);
    c.drawImage(canvas, 0,0,canvas.width,canvas.height, 36, 300, 648, 1036);
    const blob=await new Promise(r=>off.toBlob(r,'image/png',0.92));
    const file=new File([blob],'hyperrush_poster.png',{type:'image/png'});
    if (onlyPreview){
      const url=URL.createObjectURL(blob); open(url,'_blank'); setTimeout(()=>URL.revokeObjectURL(url),60000);
    } else {
      if (navigator.canShare && navigator.canShare({files:[file]})){
        try{ await navigator.share({files:[file],title:'HyperRush Poster'}); return; }catch(_){}
      }
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hyperrush_poster.png'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),60000);
    }
  }

  $('#touchCtrl').hidden = !('ontouchstart' in window);
  $('#optBgm').addEventListener('change', e=>{ if(e.target.checked) AudioKit.startBgm(); else AudioKit.stopBgm(); }, {passive:true});

})();</script>
</body>
</html>
