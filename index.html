<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,interactive-widget=resizes-content">

  <meta name="theme-color" content="#0ea5e9">
  <meta name="robots" content="noindex,nofollow">
  <title>HyperRush ‚Äî Freeze Edition</title>
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root{ --brand:#0ea5e9; --bg:#0b1220; --card:#0f172a; --text:#e5f0ff; --muted:#93a4c3; --ok:#16a34a; --bad:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0b1326 60%,#0b1220);color:var(--text);
         font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
         touch-action:manipulation;-webkit-tap-highlight-color:transparent;outline:0;
         min-height:100dvh;}

    /* FULLSCREEN: b·ªè max-width, b√°m theo viewport th·ª±c */
    #wrap{
      position:fixed; inset:0;            /* chi·∫øm tr·ªçn m√†n h√¨nh */
      width:100vw; height:100dvh;
      margin:0; max-width:none;           /* << b·ªè 480px g√¢y co nh·ªè */
      overflow:hidden;
    }

    /* ƒë√£ c√≥ r·ªìi nh∆∞ng ƒë·ªÉ ch·∫Øc ch·∫Øn */
    #game{display:block;width:100%;height:100%;background:
      radial-gradient(ellipse at 50% -10%,rgba(14,165,233,.25),transparent 55%),
      linear-gradient(180deg,#0a0f1c,#0b1220)}

    /* fallback cho m√°y c≈© kh√¥ng h·ªó tr·ª£ dvh */
    @supports not (height: 100dvh) {
      #wrap{ height:100vh; }
    }

    .ui{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
    .card{background:rgba(15,23,42,.82);backdrop-filter:blur(8px);border:1px solid rgba(148,163,184,.15);border-radius:16px;padding:18px 16px;max-width:420px;width:100%;box-shadow:0 20px 50px rgba(14,165,233,.08)}
    h1{font-size:22px;margin:0 0 4px;letter-spacing:.2px}
    p{margin:4px 0 10px;color:var(--muted);font-size:14px}
    .row{display:flex;gap:10px;margin-top:10px;align-items:center}
    button{flex:1;border:0;border-radius:12px;background:var(--brand);color:#fff;font-weight:700;padding:12px 14px;font-size:16px;box-shadow:0 10px 30px rgba(14,165,233,.25);cursor:pointer}
    button:active{transform:translateY(1px)}
    input[type="text"]{flex:1;background:#0b1220;border:1px solid rgba(148,163,184,.2);border-radius:12px;color:#fff;padding:10px 12px;outline:none}
    label.switch{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    /* HUD b√°m theo b·ªÅ r·ªông canvas + layout 2 h√†ng (pills tr√™n, energy bar d∆∞·ªõi) */
    .hud{
      position:absolute;
      top:max(8px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      width:var(--cw);
      padding:8px 12px;
    
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;                 /* üëà Cho ph√©p xu·ªëng h√†ng */
      z-index:40;
    }
    .hud .pill{
      display:inline-flex;
      align-items:center;
      height:28px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(2,6,23,.55);
      border:1px solid rgba(148,163,184,.15);
      white-space:nowrap;             /* üëà Kh√¥ng b·∫ª ch·ªØ ·ªü h√†ng 1 */
    }

    .pill{background:rgba(2,6,23,.55);border:1px solid rgba(148,163,184,.15);padding:8px 12px;border-radius:999px}
    .hint{font-size:12px;color:var(--muted)}
    .small{font-size:12px}
    .center{text-align:center}
    .mt8{margin-top:8px}
    .row-small{display:flex;gap:8px;margin-top:8px}

    #gauge{position:absolute;right:8px;top:46px;width:64px;height:64px;border-radius:999px;background:rgba(2,6,23,.45);border:1px solid rgba(148,163,184,.15);display:flex;align-items:center;justify-content:center;z-index:50;pointer-events:none}
    #gcv{width:56px;height:56px;display:block}
    #toast{position:absolute;left:50%;top:58px;transform:translateX(-50%);padding:6px 10px;background:rgba(250,250,250,.12);border:1px solid rgba(255,255,255,.2);border-radius:999px;font-size:12px;opacity:0;transition:opacity .18s, transform .18s;z-index:45}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
    [hidden]{display:none !important;}

    #game{ touch-action:none; }
    html,body,#wrap{ overscroll-behavior:none; }

    .touch-ctrl{ position:absolute;left:0;right:0;bottom:18px; display:flex;justify-content:space-between;padding:0 18px;pointer-events:none;z-index:35 }
    .touch-ctrl button{ width:64px;height:64px;border-radius:999px;border:0;background:rgba(2,6,23,.35);color:#fff;font-size:22px;border:1px solid rgba(148,163,184,.18);box-shadow:0 10px 20px rgba(0,0,0,.2); pointer-events:auto }

    #tut{position:absolute;inset:0;background:rgba(2,6,23,.7);display:flex;align-items:center;justify-content:center;z-index:60}
    #tut .card{max-width:460px}

    @media (prefers-reduced-motion: reduce){
      #toast{transition:none}
    }
    :root{
      /* s·∫Ω ƒë∆∞·ª£c JS c·∫≠p nh·∫≠t m·ªói l·∫ßn fitCanvas() ch·∫°y */
      --cw: 360px; /* canvas width hi·ªÉn th·ªã */
      --ch: 640px; /* canvas height hi·ªÉn th·ªã */
    }

    /* #wrap chi·∫øm tr·ªçn m√†n h√¨nh + cƒÉn gi·ªØa canvas ·ªü PC */
    #wrap{
      position: fixed; inset: 0;
      width: 100vw; height: 100dvh;           /* full m√†n h√¨nh th·ª±c tr√™n mobile */
      margin: 0; max-width: none; overflow: hidden;
      display: grid; place-items: center;      /* canvas v√†o ƒë√∫ng gi·ªØa */
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        calc(env(safe-area-inset-bottom) + 8px)
        env(safe-area-inset-left);
    }

    /* Canvas c√≥ bo g√≥c + b√≥ng nh·∫π cho PC */
    #game{ border-radius: 14px; box-shadow: 0 28px 80px rgba(14,165,233,.12); }

    /* HUD b√°m theo b·ªÅ r·ªông canvas (ƒë·∫πp tr√™n PC, kh√¥ng l·ªách tr√°i) */
    .hud{
      position: absolute;
      top: max(8px, env(safe-area-inset-top));
      left: 50%; transform: translateX(-50%);
      width: var(--cw);                         /* cƒÉn theo canvas */
      padding: 8px 12px;
    }

    /* Gauge b√°m m√©p ph·∫£i c·ªßa canvas (kh√¥ng d·∫°t ra r√¨a m√†n h√¨nh) */
    #gauge{
      position: absolute;
      top: calc(max(46px, env(safe-area-inset-top) + 38px));
      right: calc(50% - var(--cw)/2 + 8px);     /* m√©p ph·∫£i canvas + 8px */
    }

    /* Toast gi·ªØ theo t√¢m canvas */
    #toast{
      left: 50%; transform: translateX(-50%);
    }

    /* C·ª•m n√∫t ch·∫°m b√°m ƒë√°y canvas + safe-area */
    .touch-ctrl{
      position: absolute; left: 50%; transform: translateX(-50%);
      width: var(--cw);
      bottom: max(18px, env(safe-area-inset-bottom));
      padding: 0 18px;
    }

    /* TƒÉng c·ª° ch·ªØ HUD theo m√†n l·ªõn nh∆∞ng kh√¥ng qu√° to */
    .pill{ font-size: clamp(12px, 1.2vw, 16px); }

    /* PC l·ªõn: bo g√≥c & b√≥ng ƒë·∫≠m h∆°n ch√∫t */
    @media (min-width: 900px){
      #game{ border-radius: 18px; }
    }
    /* ==== Energy bar ==== */
    /* ==== Energy bar: chi·∫øm tr·ªçn h√†ng th·ª© 2, full b·ªÅ r·ªông canvas ==== */
    #energyWrap{
      order: 99;                 /* ƒë·ª©ng cu·ªëi h√†ng 1 c·ªßa HUD */
      flex: 0 0 100%;            /* bu·ªôc xu·ªëng h√†ng ri√™ng */
      width: min(33vw, var(--cw));  /* 1/3 viewport, nh∆∞ng kh√¥ng v∆∞·ª£t b·ªÅ r·ªông canvas */
      height: clamp(8px, 1.4vh, 12px);
      margin: 6px auto 0;        /* cƒÉn gi·ªØa ngang */
    
      background: rgba(2,6,23,.55);
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 999px;
      overflow: hidden;
      box-shadow:
        inset 0 1px 2px rgba(255,255,255,.06),
        0 0 0 1px rgba(2,6,23,.25);
    }
    #energyFill{
      height:100%;
      width:100%;                     /* JS s·∫Ω c·∫≠p nh·∫≠t width:% */
      transform-origin:left center;
      transition:width .18s cubic-bezier(.2,.6,.2,1);
      background:linear-gradient(90deg,#16a34a,#22d3ee);  /* >60% xanh */
      box-shadow:inset 0 0 12px rgba(34,211,238,.25);
    }
    @media (min-width:900px){
      #energyWrap{ height:14px; }
    }

    #aboutBar{
      position:absolute;
      left:8px;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
      font-size:12px;
      color: var(--muted);
      opacity:.9;
      pointer-events:none;
      z-index: 9999;                 /* cao nh·∫•t */
      text-shadow: 0 1px 2px rgba(0,0,0,.35);
    }
  /* ===== TopSheet (B·∫£ng x·∫øp h·∫°ng) ===== */
  #topSheet{
    position:fixed; inset:0; display:none; z-index:70;
    background:rgba(2,6,23,.55); backdrop-filter:blur(6px);
  }
  #topSheet.show{ display:flex; align-items:flex-end; justify-content:center; }
  #topSheet .panel{
    width:min(720px, 96vw); max-height:82vh; background:rgba(15,23,42,.95);
    border:1px solid rgba(148,163,184,.18); border-radius:16px 16px 0 0; padding:12px 12px 16px;
    box-shadow:0 24px 60px rgba(14,165,233,.14); display:flex; flex-direction:column; gap:10px;
  }
  #topSheet .grip{ width:56px; height:5px; border-radius:999px; background:rgba(148,163,184,.25); margin:6px auto 2px; }
  #topSheet .head{ display:flex; gap:8px; }
  #topSheet .head input, #topSheet .head select{
    flex:1; background:#0b1220; color:#e5f0ff; border:1px solid rgba(148,163,184,.25);
    border-radius:10px; padding:8px 10px; outline:none;
  }
  #topSheet .head select{ flex:0 0 140px; }
  #podium{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }
  #podium .card{
    background:rgba(2,6,23,.55); border:1px solid rgba(148,163,184,.18);
    border-radius:12px; padding:10px; text-align:center;
  }
  #podium .card.r1{ transform:translateY(-6px); }
  #topList{ overflow:auto; min-height:120px; max-height:42vh; border:1px solid rgba(148,163,184,.12);
    border-radius:10px; background:rgba(2,6,23,.35); padding:6px; }
  #topList .row{ display:grid; grid-template-columns:52px 1fr 90px; align-items:center;
    padding:8px 10px; border-radius:10px; }
  #topList .row:nth-child(odd){ background:rgba(2,6,23,.25); }
  #topList .row.me{ outline:2px solid #22d3ee; background:rgba(34,211,238,.08); }
  #topList .rk{ color:#93a4c3; font-weight:700; }
  #topList .nm{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  #topList .sc{ text-align:right; font-weight:700; }
  #btnMore{ margin-top:8px; border:0; border-radius:10px; padding:10px 12px; font-weight:700;
    background:#0ea5e9; color:#fff; cursor:pointer; }
  #btnCloseTop{
    position:absolute; right:14px; top:12px; width:36px; height:36px; border-radius:999px; border:0;
    background:rgba(2,6,23,.6); color:#e5f0ff; font-size:18px; cursor:pointer; border:1px solid rgba(148,163,184,.18);
  }
  #cntDown{ justify-content:center; min-width:64px; }
  /* HUD ph·∫£i ·ªü tr√™n gauge */
  .hud{ z-index: 60; }
  
  /* Pill ƒë·∫øm ng∆∞·ª£c: lu√¥n s·∫µn s√†ng hi·ªÉn th·ªã */
  #cntDown{
    display: inline-flex !important;
    justify-content: center;
    min-width: 64px;
    visibility: visible !important;
    opacity: 1 !important;
  }
  /* Ch·ªâ d√πng energy bar, ·∫©n h·∫≥n v√≤ng tr√≤n gauge */
  #gauge, #gcv { display: none !important; }

  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640" aria-label="HyperRush Freeze"></canvas>
    <div id="aboutBar" aria-hidden="true">
      <span id="verLabel">v0.9.3</span> ‚Ä¢ <span id="authorLabel">L√¢m ƒë·∫°i ka</span>
    </div>

    <div id="uiStart" class="ui" role="dialog" aria-modal="true">
      <div class="card">
        <h1>HyperRush ‚Äî Freeze v0.093.1 - by L√¢m ƒëaÃ£ika</h1>
        <p>Gi·ªØ ch·∫°m ƒë·ªÉ <b>Freeze</b>. Vu·ªët ngang ƒë·ªÉ <b>k√©o</b> nh√¢n v·∫≠t ‚Äì kh√¥ng nh·∫£y b·∫≠c.</p>
        <div class="row">
          <input id="name" type="text" maxlength="16" placeholder="T√™n hi·ªÉn th·ªã (tu·ª≥ ch·ªçn)">
          <button id="btnPlay">Ch∆°i ngay</button>
        </div>
        <div class="row-small">
          <label class="switch"><input id="optTilt" type="checkbox"> Nghi√™ng m√°y ƒë·ªÉ l√°i</label>
          <label class="switch"><input id="optBgm" type="checkbox"> Nh·∫°c n·ªÅn</label>
        </div>
        <p class="hint">PC: A/D ho·∫∑c ‚Üê ‚Üí; Space = Freeze ‚Ä¢ Mobile: vu·ªët li√™n t·ª•c, ch·∫°m tr√°i/ph·∫£i ƒë·ªÉ ƒë·ªïi l√†n nhanh.</p>
        <div class="small">B·∫£n ƒë·ªì thay ƒë·ªïi m·ªói ng√†y. C·ªë g·∫Øng v∆∞·ª£t 2.500!</div>
        <div class="row-small">
          <button id="btnTop">Top 100 ng√†y</button>
          <button id="btnTut">H∆∞·ªõng d·∫´n</button>
        </div>
      </div>
      <!-- ===== TopSheet: B·∫£ng x·∫øp h·∫°ng ng√†y ===== -->
      <div id="topSheet" aria-hidden="true">
        <div class="panel" role="dialog" aria-modal="true" aria-label="B·∫£ng x·∫øp h·∫°ng">
          <button id="btnCloseTop" title="ƒê√≥ng" onclick="TopSheet.close()">‚úï</button>
          <div class="grip"></div>
          <div class="head">
            <input id="topSearch" type="text" placeholder="T√¨m t√™n ng∆∞·ªùi ch∆°i‚Ä¶">
            <select id="topFilter">
              <option value="all">T·∫•t c·∫£</option>
              <option value="vn">Ch·ªâ VN</option>
              <option value="around">Quanh t√¥i</option>
            </select>
          </div>
      
          <div id="podium" aria-label="Top 3"></div>
      
          <div id="topList" tabindex="0" aria-label="Danh s√°ch Top 100"></div>
          <button id="btnMore">Xem th√™m</button>
        </div>
      </div>

    </div>

    <div id="uiHUD" class="hud" hidden>
      <div class="pill">ƒêi·ªÉm: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill small" id="stageLabel">Stage 1</div>
      <div class="pill small" id="multLabel">x1.0</div>
      <div class="pill small" id="cntDown" hidden>‚ö† 10.0s</div>
      <div class="pill small" id="playerName" hidden></div>
        <!-- Energy bar -->
      <div id="energyWrap">
        <div id="energyFill"></div>
      </div>

    </div>

    <div id="uiOver" class="ui" hidden role="dialog" aria-modal="true">
      <div class="card center">
        <h1>Thua r·ªìi!</h1>
        <p>ƒêi·ªÉm: <b id="finalScore">0</b> ‚Ä¢ Best: <b id="best2">0</b></p>
        <div id="overMsg" class="hint mt8"></div>
        <div class="row mt8">
          <button id="btnRetry">Ch∆°i l·∫°i</button>
          <button id="btnShare">Chia s·∫ª</button>
        </div>
        <div class="row mt8">
          <button id="btnPoster">T·∫°o ·∫£nh Poster</button>
          <button id="btnSave">T·∫£i Poster</button>
        </div>
      </div>
    </div>

    <div id="tut" hidden>
      <div class="card">
        <h1>H∆∞·ªõng d·∫´n nhanh (5s)</h1>
        <p>‚Ä¢ Gi·ªØ tay ƒë·ªÉ <b>l√†m ch·∫≠m</b> th·ªùi gian (Freeze).<br>
           ‚Ä¢ Vu·ªët <b>m∆∞·ª£t</b> ƒë·ªïi l√†n ‚Äî kh√¥ng nh·∫£y b·∫≠c. <br>
           ‚Ä¢ S∆∞·ª£t ch∆∞·ªõng ng·∫°i <b>g·∫ßn</b> s·∫Ω ƒë∆∞·ª£c c·ªông nƒÉng l∆∞·ª£ng & combo. <br>
           ‚Ä¢ Orb xanh tƒÉng ƒëi·ªÉm + nƒÉng l∆∞·ª£ng. <br>
           ‚Ä¢ M·ªói 300 ƒëi·ªÉm c√≥ <b>Stage</b> m·ªõi, c·ª≠a h·∫πp 3s.</p>
        <div class="row"><button id="btnOkTut">Hi·ªÉu r·ªìi</button></div>
      </div>
    </div>

    <div id="gauge" aria-label="Freeze energy"><canvas id="gcv" width="96" height="96"></canvas></div>
    <div id="toast">NEAR-MISS +6%</div>

    <div id="touchCtrl" class="touch-ctrl" hidden>
      <button id="btnL">‚óÄ</button>
      <button id="btnR">‚ñ∂</button>
    </div>


  </div>

<script>
(() => {
  'use strict';
/* === Utils ƒë·∫∑t l√™n ƒë·∫ßu ƒë·ªÉ d√πng ngay === */
const $ = sel => document.querySelector(sel);
// B·∫£o hi·ªÉm: n·∫øu thi·∫øu <div id="cntDown"> th√¨ t·ª± ch√®n tr∆∞·ªõc energy bar
if (!document.getElementById('cntDown')) {
  const pill = document.createElement('div');
  pill.id = 'cntDown';
  pill.className = 'pill small';
  pill.hidden = true;
  const hud = document.getElementById('uiHUD');
  const energyWrap = document.getElementById('energyWrap');
  hud.insertBefore(pill, energyWrap || hud.firstChild);
}

// == Countdown HUD helpers (robust) ==
const $cnt = document.getElementById('cntDown');

function showCountdown(sec){
  if (!$cnt) return;
  // G·ª° hidden theo c·∫£ 2 c√°ch ƒë·ªÉ tri·ªát rule [hidden]{display:none !important;}
  $cnt.hidden = false;
  $cnt.removeAttribute('hidden');

  // √âp inline ƒë·ªÉ th·∫Øng m·ªçi CSS kh√°c
  $cnt.style.display = 'inline-flex';
  $cnt.style.visibility = 'visible';
  $cnt.style.opacity = '1';

  $cnt.textContent = `‚ö† ${sec}s`;
}

function hideCountdown(){
  if (!$cnt) return;
  // C√†i l·∫°i hidden theo c·∫£ property + attribute
  $cnt.hidden = true;
  $cnt.setAttribute('hidden', '');

  // Tr·∫£ style v·ªÅ m·∫∑c ƒë·ªãnh
  $cnt.style.display = '';
  $cnt.style.visibility = '';
  $cnt.style.opacity = '';
}


/* META hi·ªÉn th·ªã g√≥c tr√°i d∆∞·ªõi */
const META = { version: '', author: '' };

function initMeta(){
  const ver = document.getElementById('verLabel');
  const au  = document.getElementById('authorLabel');
  if (ver) ver.textContent = META.version || '';
  if (au)  au.textContent  = META.author  || '';
}

/* g·ªçi nhi·ªÅu nh·ªãp ƒë·ªÉ tr√°nh l·ªách th·ªùi ƒëi·ªÉm attach DOM */
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMeta, {once:true});
} else {
  initMeta();
}
window.addEventListener('pageshow', initMeta);
setTimeout(initMeta, 0);
setTimeout(initMeta, 500);



  /* =============== Config =============== */
  const CONFIG = {
    API_URL: 'https://script.google.com/macros/s/AKfycbznfw8rrffCKv0OObRRc8j6YHKir6dEwpLrG4eNn-Azc3xvg4_UrI3fbUoBRv6Dq-e1DQ/exec',
    AUDIO: { enabled: true, volume: 0.32, sfxUrl: '', bgmUrl: '' },

    // ‚Üì Gi·ªØ m∆∞·ª£t cho ƒëa s·ªë m√°y, √≠t ‚Äún·ªï h·∫°t‚Äù h∆°n
    PERF:  { dprMax: 1.25, maxEntities: 90, maxParticles: 140, minDpr: 0.90 },

    // ‚Üì Nh·ªãp game ch·∫≠m h∆°n, r·ªông ƒë∆∞·ªùng h∆°n, h·ªìi nƒÉng l∆∞·ª£ng d·ªÖ th·ªü h∆°n
    GAME: {
      lanes: 3,
      baseSpeed: 110,
      accel: 0.035,
      spawnEvery: 880,
      spawnAccel: 0.994,
      minSpawnEvery: 320,
      maxSpawnsPerFrame: 4,
    
      orbChance: 0.38,
      freezeRate: 0.08,         // ‚¨ÖÔ∏è 0.26  ‚Üí  0.08  (~8%/gi√¢y, tho·∫£i m√°i h∆°n)
      regenPassive: 0.012,      // ‚¨ÖÔ∏è 0.0055 ‚Üí  0.012 (~1.2%/gi√¢y khi KH√îNG gi·ªØ)
      regenNear: 10,            // ‚¨ÖÔ∏è 8   ‚Üí  10  (s∆∞·ª£t g·∫ßn h·ªìi s∆∞·ªõng h∆°n)
      regenOrb: 18,             // ‚¨ÖÔ∏è 14  ‚Üí  18
      freezeSlow: 0.50,         // ‚¨ÜÔ∏è 0.45 ‚Üí 0.50 (Freeze hi·ªáu qu·∫£ h∆°n ch√∫t)
    
      minGapObPx: 160,
      minGapOrbPx: 130,
      minGapMixPx: 150,
    
      maxSpawnAttempts: 4,
      surgeEvery: 400,
      surgeMs: 2600,
      graceMs: 2000
    }

  };
  window.CONFIG = CONFIG;

  const THEME_PRO = true; // true = n·ªÅn pro, false = n·ªÅn s·∫°ch t·ªëi gi·∫£n

  const TIERS = {
    // base = ƒë·ªì ho·∫° ƒë·∫ßy ƒë·ªß
    base:{ maxEntities:90,  maxParticles:140, minSpawnEvery:320, cap:5,  roadStep:44, dprAdj:0 },
    // mid = gi·∫£m v·∫Ω nh·∫π, spawn th∆∞a h∆°n
    mid :{ maxEntities:70,  maxParticles:100, minSpawnEvery:360, cap:4,  roadStep:56, dprAdj:-0.10 },
    // low = ti·∫øt ki·ªám t·ªëi ƒëa cho m√°y y·∫øu
    low :{ maxEntities:55,  maxParticles:70,  minSpawnEvery:400, cap:3,  roadStep:68, dprAdj:-0.22 }
  };


  /* ===== Anti-exploit ===== */
  /* ===== Anti-exploit (tinh ch·ªânh) ===== */
  const ANTI = {
    campMs: 1800,          // >1.8 s kh√¥ng ƒë·ªïi l√†n
    campCooldownMs: 1000,  // gi√£n c√°ch gi·ªØa 2 l·∫ßn √©p
    spawnJitter: 90        // ‚Üë tƒÉng bi√™n ƒë·ªô jitter (‚âà minGap/2)
  };
  /* ‚Äî‚Äî Anti "gi·ªØ gi·ªØa 2 l√†n" exploit ‚Äî‚Äî */
  const ANTI_MID = {
    bandL: 0.42,           // bi√™n tr√°i v√πng gi·ªØa (0..1)
    bandR: 0.58,           // bi√™n ph·∫£i v√πng gi·ªØa
    drainMul: 2.6,         // nh√¢n hao nƒÉng l∆∞·ª£ng khi gi·ªØ ·ªü gi·ªØa
    nearPenalty: 0.18,     // % h·ªìi nƒÉng l∆∞·ª£ng Near khi ƒëang gi·ªØ (18%)
    nearCooldownMs: 700,   // k√©o d√†i cooldown Near khi ƒëang gi·ªØ
    slipGiveEnergyWhenFreeze: false // Slip ƒëang gi·ªØ th√¨ kh√¥ng h·ªìi nƒÉng l∆∞·ª£ng
  };

  /* --------- Auto-snap nh√¢n v·∫≠t v·ªÅ t√¢m l√†n --------- */
  const AUTO_SNAP = {      // T·∫Øt = ƒë·∫∑t enable:false
    enable: true,          // true = b·∫≠t
    speed : 0.12           // 0.10-0.18 ‚Üí c√†ng l·ªõn c√†ng snap nhanh
  };

  // B·∫≠t debug b·∫±ng ?debug=1
  const DBG = new URLSearchParams(location.search).get('debug') === '1';


  const LOW = (navigator.hardwareConcurrency && navigator.hardwareConcurrency<=4);
  if (LOW){ CONFIG.PERF.dprMax=1.2; CONFIG.PERF.maxParticles=140; }
  /* ===== Freeze UX ===== */
  const FREEZE = {
    minToStart: 6,         // <6% th√¨ KH√îNG cho b·∫≠t Freeze (tr√°nh ‚Äúb·∫•m l√† c·∫°n‚Äù)
    freeMs: 180,           // 180ms ƒë·∫ßu MI·ªÑN PH√ç hao nƒÉng l∆∞·ª£ng
    rampMs: 900,           // sau ƒë√≥ tƒÉng d·∫ßn m·ª©c hao trong 0‚Üí900ms
    rampMin: 0.35,         // m·ª©c hao ban ƒë·∫ßu = 35% c·ªßa freezeRate
    rearmPct: 14,          // khi t·ª•t 0% th√¨ ph·∫£i h·ªìi l·∫°i ‚â•14% m·ªõi cho b·∫≠t l·∫°i
    warnCooldownMs: 1200   // ch·ªëng spam th√¥ng b√°o
  };
  /* ===== Speed theo Stage & Death-by-Fatigue ===== */
  const SPEED_STAGE = { perStage: 0.08, max: 280 };   // +8%/stage, tr·∫ßn 280 px/s
  const ENERGY_DEATH = { enable: true, windowMs: 10000, revivePct: 6 };

  /* =============== Utils =============== */

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();
  const mqlReduce = matchMedia('(prefers-reduced-motion: reduce)');

  function vibrate(p){ try{ if(!mqlReduce.matches) navigator.vibrate && navigator.vibrate(p);}catch(_){ } }

  function getDeviceId(){
    const k='hrfz_device_id'; let id=localStorage.getItem(k);
    if(!id){ id=crypto.getRandomValues(new Uint32Array(4)).join('-'); localStorage.setItem(k,id); }
    return id;
  }
  function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }

  const BASE_W=360, BASE_H=640, MARGIN=40; let DPR=1, ROAD_STEP=40;

  function fitCanvas(canvas){
    const ratio = BASE_W / BASE_H;

    // K√≠ch th∆∞·ªõc viewport "th·ª±c" (·∫©n/hi·ªán URL bar, b√†n ph√≠m‚Ä¶)
    const w = Math.max(1, (window.visualViewport?.width || window.innerWidth));
    const h = Math.max(1, (window.visualViewport?.height || window.innerHeight));

    // T√≠nh size canvas theo t·ªâ l·ªá 360x640
    let cw = w, ch = w / ratio;
    if (ch > h) { ch = h; cw = h * ratio; }

    // Style k√≠ch th∆∞·ªõc hi·ªÉn th·ªã
    canvas.style.width  = cw + 'px';
    canvas.style.height = ch + 'px';

    // C·∫≠p nh·∫≠t bi·∫øn CSS ƒë·ªÉ HUD/gauge/n√∫t b√°m theo ƒë√∫ng b·ªÅ r·ªông canvas
    document.documentElement.style.setProperty('--cw', cw + 'px');
    document.documentElement.style.setProperty('--ch', ch + 'px');

    // DPR an to√†n theo c·∫•u h√¨nh hi·ªáu nƒÉng
    const dprTarget = clamp((window.devicePixelRatio || 1), CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    DPR = dprTarget;

    // K√≠ch th∆∞·ªõc buffer v·∫Ω
    canvas.width  = Math.round(BASE_W * DPR);
    canvas.height = Math.round(BASE_H * DPR);

    // Scale h·ªá to·∫° ƒë·ªô v·ªÅ ƒë∆°n v·ªã logic (BASE_W x BASE_H)
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }



  function dailySeed(){
    const d=new Date(); const s=Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())>>>0;
    return s ^ (getDeviceId().split('-')[0]>>>0);
  }

  /* ====== Spawn table ƒë·ªông ====== */
  // ‚ú® Kho·∫£ng c√°ch t·ªëi thi·ªÉu t√πy c·∫∑p lo·∫°i
  function needGapBetween(typeA, typeB){
    if (typeA === 'ob'  && typeB === 'ob')  return CONFIG.GAME.minGapObPx;
    if (typeA === 'orb' && typeB === 'orb') return CONFIG.GAME.minGapOrbPx;
    return CONFIG.GAME.minGapMixPx; // kh√°c lo·∫°i
  }

  // ‚ú® Lane c√≥ ƒë·ªß kho·∫£ng c√°ch ƒë·ªÉ spawn y0 cho 'type' kh√¥ng?
  function okGapForLane(lane, type, y0){
    // y tƒÉng theo chi·ªÅu xu·ªëng; spawn ·ªü y0 √¢m ‚áí y0 ph·∫£i "tr√™n" ƒë·ªß xa so v·ªõi m·ªçi entity c√πng l√†n
    for (let i = state.entities.length - 1; i >= 0; i--){
      const e = state.entities[i];
      if (e.lane !== lane) continue;
      const need = needGapBetween(type, e.type);
      if ((y0 - e.y) > -need) return false; // ch∆∞a ƒë·ªß kho·∫£ng c√°ch
    }
    return true;
  }
  // --- Utils tr√°nh spawn "b·ªãt 3 c·ªôt" ---
  function rowBlocked(y0){
    // qu√©t ¬±minGapObPx quanh to·∫° ƒë·ªô Y chu·∫©n b·ªã spawn
    const band = CONFIG.GAME.minGapObPx;
    const occ  = new Array(CONFIG.GAME.lanes).fill(false);

    for (const e of state.entities){
      if (e.type !== 'ob') continue;               // ch·ªâ x√©t obstacle
      if (Math.abs(e.y - y0) <= band) occ[e.lane] = true;
    }
    return occ.every(Boolean);                    // true = c·∫£ 3 lane ƒë√£ k√≠n
  }

  function makeSpawnTable(base, accel, minMs, limit=4096){
    const out=[]; let v=base, i=0;
    while (i<limit && v>minMs){ out.push(v); v*=accel; i++; }
    out.push(minMs); return new Float32Array(out);
  }
  let SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  function rebuildSpawnTable(minMs){
    CONFIG.GAME.minSpawnEvery = minMs;
    SPAWN_TABLE = makeSpawnTable(CONFIG.GAME.spawnEvery, CONFIG.GAME.spawnAccel, CONFIG.GAME.minSpawnEvery);
  }

  /* ----- Hitbox & h√¨nh h·ªçc ----- */
  const HIT = { P_W:30, P_H:30, OB_W:36, OB_H:36, NEAR_PAD:8 };
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return (Math.abs(ax - bx) <= (aw + bw) * 0.5) && (Math.abs(ay - by) <= (ah + bh) * 0.5);
  }
  function laneWidth(){ return (W - MARGIN*2)/CONFIG.GAME.lanes; }

  /* ====== Link c·∫£nh b√°o gi·ªØa 2 l√†n ====== */
  const links = []; // {y, age, life, strong}
  function addLink(y, strong){
    if (links.length>24) links.shift();
    links.push({y, age:0, life:420, strong:!!strong});
  }

  /* =============== Audio =============== */
  const AudioKit = (function(){
    let ctx, master, sfxBuf=null, bgm=null, bgmGain=null;
    function ensure(){
      if (!CONFIG.AUDIO.enabled) return null;
      if (!ctx){ ctx=new (window.AudioContext||window.webkitAudioContext)(); master=ctx.createGain(); master.gain.value=CONFIG.AUDIO.volume; master.connect(ctx.destination); }
      return ctx;
    }
    async function load(url){ const c=ensure(); if(!c||!url) return null;
      try{ const r=await fetch(url); const a=await r.arrayBuffer(); return await c.decodeAudioData(a);}catch(_){return null;}
    }
    async function prepare(){ if(!ensure()) return; if(CONFIG.AUDIO.sfxUrl && !sfxBuf) sfxBuf=await load(CONFIG.AUDIO.sfxUrl); }
    function unlock(){ const c=ensure(); if(!c) return; if(c.state==='suspended') c.resume().catch(()=>{}); }
    function playBuf(buf,time=0,off=0,dur){ if(!buf) return; const c=ensure(); const src=c.createBufferSource(); src.buffer=buf; src.connect(master); if(dur) src.start(c.currentTime+time,off,dur); else src.start(c.currentTime+time,off); }
    const SPR={ move:[0.00,0.08], near:[0.10,0.10], orb:[0.22,0.16], freeze_on:[0.40,0.12], hit:[0.56,0.22], taunt:[0.80,0.20] };
    function tone(o){ const c=ensure(); if(!c) return; const osc=c.createOscillator(), g=c.createGain();
      osc.type=o.type||'sine'; osc.frequency.value=o.freq||440; if(o.detune) osc.detune.value=o.detune;
      g.gain.value=0; osc.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, d=o.decay||0.12, s=o.sustain||0.0001, r=o.release||0.08, v=o.gain||0.4;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(s,t+a+d); g.gain.linearRampToValueAtTime(0,t+a+d+r);
      osc.start(t); osc.stop(t+a+d+r+0.01);
    }
    function noise(o){ const c=ensure(); if(!c) return;
      const b=c.createBuffer(1, c.sampleRate*0.18, c.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1);
      const src=c.createBufferSource(); src.buffer=b; const g=c.createGain(); g.gain.value=0; src.connect(g); g.connect(master);
      const t=c.currentTime, a=o.attack||0.005, r=o.release||0.14, v=o.gain||0.45;
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.linearRampToValueAtTime(0,t+a+r);
      src.start(t); src.stop(t+a+r+0.01);
    }
    function sfx(n){
      if (sfxBuf && SPR[n]){ const [off,dur]=SPR[n]; return playBuf(sfxBuf,0,off,dur); }
      switch(n){ case 'move': tone({type:'square',freq:640,gain:0.18,decay:0.06,release:0.06}); break;
        case 'near': tone({type:'triangle',freq:880,gain:0.22,decay:0.04}); break;
        case 'orb':  tone({type:'sine',freq:520,gain:0.26,decay:0.05}); tone({type:'sine',freq:780,gain:0.20,decay:0.07}); break;
        case 'freeze_on': tone({type:'sawtooth',freq:300,gain:0.18,decay:0.08}); break;
        case 'hit':  noise({gain:0.6}); tone({type:'square',freq:140,gain:0.25,decay:0.09,release:0.2}); break;
        case 'taunt': tone({type:'triangle',freq:480,gain:0.16,decay:0.12}); break; }
    }
    async function startBgm(){ if(!CONFIG.AUDIO.bgmUrl) return; const c=ensure(); if(!c) return;
      if(!bgm){ const buf=await load(CONFIG.AUDIO.bgmUrl); if(!buf) return;
        const src=c.createBufferSource(); src.buffer=buf; src.loop=true; bgmGain=c.createGain(); bgmGain.gain.value=0; src.connect(bgmGain); bgmGain.connect(master); src.start();
        bgm=src; const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0.25,t+1.2); } }
    function stopBgm(){ if(bgmGain){ const c=ensure(); const t=c.currentTime; bgmGain.gain.linearRampToValueAtTime(0,t+0.6); } }
    return {unlock,prepare,sfx,startBgm,stopBgm};
  })();

  /* =============== Backend =============== */
  /* ---- G·ª≠i ƒëi·ªÉm: beacon ‚Üí no-cors ‚Üí JSONP (GET write) ---- */
  async function postScore(payload) {
    if (!CONFIG.API_URL) return;
    const data = JSON.stringify(payload);

    // 1) ∆Øu ti√™n sendBeacon (an to√†n khi tab ƒë√≥ng, kh√¥ng c·∫ßn CORS)
    try {
      if (navigator.sendBeacon) {
        const ok = navigator.sendBeacon(
          CONFIG.API_URL,
          new Blob([data], { type: 'text/plain' })
        );
        if (ok) return; // ƒë√£ g·ª≠i xong
      }
    } catch (_) {}

    // 2) Fallback: fetch no-cors (g·ª≠i ƒë∆∞·ª£c nh∆∞ng kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ph·∫£n h·ªìi)
    try {
      await fetch(CONFIG.API_URL, {
        method: 'POST',
        mode: 'no-cors',                // tr√°nh CORS
        headers: { 'Content-Type': 'text/plain' }, // simple request
        body: data,
        keepalive: true                 // v·∫´n g·ª≠i khi unload
      });
      return;
    } catch (_) {}

    // 3) Fallback cu·ªëi: JSONP (GET write) ‚Äì kh√¥ng c·∫ßn CORS, server s·∫Ω ghi t·ª´ query
    await new Promise((resolve) => {
      const cb = 'hr_post_' + Math.random().toString(36).slice(2);
      // h·∫°n ch·∫ø ƒë·ªô d√†i UA tr√°nh URL qu√° d√†i
      const uaShort = (payload.ua || '').slice(0, 160);

      window[cb] = () => { try{ delete window[cb]; }catch(_){ } s.remove(); resolve(); };
      const s = document.createElement('script');
      s.src = CONFIG.API_URL + '?' + new URLSearchParams({
        act: 'w', fmt: 'js', cb,
        deviceId: payload.deviceId,
        name: payload.name || '',
        score: String(payload.score || 0),
        tz: payload.tz || '',
        ua: uaShort
      }).toString();
      s.onerror = () => {
        try{ delete window[cb]; }catch(_){ } s.remove();
        const t = document.getElementById('toast');
        if (t) { t.textContent = 'Kh√¥ng g·ª≠i ƒë∆∞·ª£c ƒëi·ªÉm (Net)'; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1200); }
        resolve();
      };
      document.head.appendChild(s);
    });
  }


  async function fetchTop(){
    const url = CONFIG.API_URL + '?top=10';
    try {
      const r = await fetch(url, {
        mode: 'cors',
        signal: (AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined)
      });
      return await r.json();                       // {items:[...]}
    } catch (err) {
      // Fallback JSONP: kh√¥ng c·∫ßn CORS
      return new Promise((resolve, reject) => {
        const cb = 'hr_cb_' + Math.random().toString(36).slice(2);
        window[cb] = (data) => { try{ delete window[cb]; }catch(_){}
                              s.remove(); resolve(data); };
        const s = document.createElement('script');
        s.src = CONFIG.API_URL + '?top=100&fmt=js&cb=' + cb;
        s.onerror = () => { try{ delete window[cb]; }catch(_){}
                            s.remove(); reject(new Error('jsonp_error')); };
        document.head.appendChild(s);
      });
    }
  }


  /* =============== Game State =============== */
  const canvas = $('#game'); 
  const ctx = canvas.getContext('2d');
  fitCanvas(canvas);
  addEventListener('resize', () => fitCanvas(canvas));
  if (window.visualViewport){
    visualViewport.addEventListener('resize', () => fitCanvas(canvas));
    visualViewport.addEventListener('scroll',  () => fitCanvas(canvas)); // khi URL bar tr∆∞·ª£t
  }
  new ResizeObserver(() => fitCanvas(canvas)).observe($('#wrap'));


  const gcv = $('#gcv');
  const gctx = gcv ? gcv.getContext('2d') : null;  // guard n·∫øu b·ªã ·∫©n/kh√¥ng c√≥


  const energyFill = $('#energyFill');

  let W=BASE_W, H=BASE_H;
  const state = {
    running:false, over:false, startedAt:0, playMs:0,
    name:'', score:0, best:Number(localStorage.getItem('hrfz_best')||0),
    rng: mulberry32(dailySeed()),
    speed: CONFIG.GAME.baseSpeed,
    lastSpawn: 0, spawnIdx: 0,
    lane: 1.0, desiredLane: 1.0, laneV:0,
    playerY: H * 0.6,
    entities: [],
    energy: 60,
    freezeAccum: 0,   
    holdStartT: 0,
    lastHoldEndT: 0,
    freezeWarnT: 0,
    freezeLocked: false,
    energyZeroT: 0,             // m·ªëc th·ªùi gian b·∫Øt ƒë·∫ßu c·∫°n nƒÉng l∆∞·ª£ng
    energyCntRemain: 0,         // ms c√≤n l·∫°i c·ªßa countdown
    _secLeft: undefined,        // s·ªë gi√¢y c√≤n l·∫°i (ƒë·ªÉ update pill m·ªói gi√¢y)
    deathReason: '',            // '' | 'fatigue'

    holding:false,
    lastNearT: 0,
    shake: 0,
    particles: [],
    surgeMs: 0, nextSurge: CONFIG.GAME.surgeEvery,
    dragging:false, dragStartX:0, dragStartLane:1.0, hasDragged:false, dragStartT:0, lastDragT: 0,
    combo:0, comboT:0,
    grace: CONFIG.GAME.graceMs,
    stage:1, lastStageAnnounce:0,
    nearMissCount:0,
    lowSpec:false, fpsEMA:60,
    gfxTier:0, _tierLockT:0, frame:0,
    lastSlipT:0,    
    energyEmptyT: 0, 
    dirMul: 1.0,        // h·ªá s·ªë ƒë·∫°o di·ªÖn nh·ªãp spawn
    _lowEnergyWarned: false,
    _surgeWarned: false,

    lastLaneChangeT: now(),      // l·∫ßn g·∫ßn nh·∫•t ƒë·ªïi l√†n nguy√™n
    _laneI: 1,                   // l√†n nguy√™n hi·ªán t·∫°i (ƒë·ªÉ so s√°nh)
    _antiCampT: 0,               // cooldown anti-camp

  };

  /* =============== Particles =============== */
  function spawnParticles(x,y,color,count=12,spd=1){
    const allow = Math.max(0, CONFIG.PERF.maxParticles - state.particles.length);
    count = Math.min(count, allow);
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      state.particles.push({ x,y, vx: Math.cos(a)*(1.2+Math.random()*2)*spd, vy: Math.sin(a)*(1.2+Math.random()*2)*spd,
        life: 420+Math.random()*260, age:0, color });
    }
  }

  /* =============== Input =============== */
  function stepLane(dir){
    const next = clamp(Math.round(state.desiredLane) + Math.sign(dir), 0, CONFIG.GAME.lanes-1);
    if (next!==Math.round(state.desiredLane)){ state.desiredLane = next; AudioKit.sfx('move'); }
  }
  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k==='arrowleft'||k==='a') stepLane(-1);
    if (k==='arrowright'||k==='d') stepLane(1);
    if (k===' ') { state.holding = true; AudioKit.sfx('freeze_on'); }
  }, {passive:true});
  addEventListener('keyup', (e)=>{ if (e.key===' ') state.holding=false; }, {passive:true});

  const TAP_TIME_MAX=160;
  const DRAG_PX_THRESHOLD=10*(window.devicePixelRatio||1);

  canvas.addEventListener('pointerdown', async (e)=>{
    if (state.dragging) return;
    state.dragging=true; state.dragStartX=e.clientX; state.dragStartLane=state.desiredLane; state.dragStartT=now();
    state.hasDragged=false; canvas.setPointerCapture?.(e.pointerId);
    state.holding=true; state.holdStartT = now(); await AudioKit.prepare(); AudioKit.unlock(); AudioKit.sfx('freeze_on'); e.preventDefault();
    state.lastDragT = now(); 
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (!state.dragging) return;
    const dx=e.clientX-state.dragStartX;
    if (Math.abs(dx)>DRAG_PX_THRESHOLD) state.hasDragged=true;
    const laneW=(W-MARGIN*2)/CONFIG.GAME.lanes;
    const cont=state.dragStartLane + dx/laneW;
    state.desiredLane=clamp(cont,0,CONFIG.GAME.lanes-1); e.preventDefault();
    state.lastDragT = now();  
  }, {passive:false});
  function endPointer(e){
    if (!state.dragging) return;
    try{ canvas.releasePointerCapture?.(e.pointerId);}catch(_){}
    const dtTap=now()-(state.dragStartT||0);
    const dx=Math.abs((e.clientX||0)-(state.dragStartX||0));
    if (!state.hasDragged && dtTap<=TAP_TIME_MAX && dx<DRAG_PX_THRESHOLD){
      const r=canvas.getBoundingClientRect(); stepLane(e.clientX < r.left+r.width/2 ? -1 : 1);
    }
    state.lastHoldEndT = now();
    state.dragging=false; state.holding=false; e.preventDefault();
  }
  canvas.addEventListener('pointerup', endPointer, {passive:false});
  canvas.addEventListener('pointercancel', endPointer, {passive:false});
  canvas.addEventListener('pointerleave', endPointer, {passive:false});

  $('#optTilt').addEventListener('change', async (e)=>{
    if (e.target.checked){
      try{
        if (typeof DeviceMotionEvent!=='undefined' && DeviceMotionEvent.requestPermission){
          const perm=await DeviceMotionEvent.requestPermission(); if (perm!=='granted') e.target.checked=false;
        }
      }catch(_){}
    }
  }, {passive:true});
  addEventListener('devicemotion', (ev)=>{
    if (!$('#optTilt').checked || !state.running) return;
    const ax = ev.accelerationIncludingGravity ? ev.accelerationIncludingGravity.x||0 : 0;
    const tilt=clamp(ax/6,-1,1);
    state.desiredLane=clamp(1+tilt,0,CONFIG.GAME.lanes-1);
  }, {passive:true});

  /* =============== Helpers =============== */
  function smoothLane(dt){
    const k=28, c=2*Math.sqrt(k), x=state.lane-state.desiredLane, a=-k*x - c*state.laneV, dtSec=dt/1000;
    state.laneV += a*dtSec; state.lane += state.laneV*dtSec; state.lane=clamp(state.lane,0,CONFIG.GAME.lanes-1);
  }
  // Ghi l·∫°i ‚Äúkhe c∆° b·∫£n‚Äù ngay sau CONFIG
  const MIN_GAP_BASE = CONFIG.GAME.minGapObPx;
  function scoreMultiplier(){
    // m·ªói near-miss trong 1.2s tƒÉng 0.1x, t·ªëi ƒëa x2.5
    const active = (now()-state.comboT < 1200) ? state.combo : 0;
    return clamp(1 + 0.10*Math.min(15, active), 1, 2.5);
  }

  function applyStages(){
    const s = Math.floor(state.score / CONFIG.GAME.surgeEvery) + 1;

    // Khi qua m·ªëc stage th√¨ c·∫≠p nh·∫≠t label + baseline
    if (s !== state.stage) {
      state.stage = s;
      $('#stageLabel').textContent = `Stage ${state.stage}`;
      if (now() - state.lastStageAnnounce > 2000) { toast(`Stage ${state.stage}!`); AudioKit.sfx('taunt'); }
      state.lastStageAnnounce = now();
    }

    // Orb v·∫´n gi·∫£m d·∫ßn theo stage nh∆∞ng nh·∫π tay h∆°n
    CONFIG.GAME.orbChance = Math.max(0.26, 0.38 - 0.02 * (state.stage - 1));

    // Khe obstacle: xu·∫•t ph√°t t·ª´ MIN_GAP_BASE, gi·∫£m ch·∫≠m theo stage
    let mg = MIN_GAP_BASE - 3 * (state.stage - 1);     // m·ªói stage ch·ªâ si·∫øt 3px
    // N·∫øu nƒÉng l∆∞·ª£ng <25% th√¨ n·ªõi khe t·∫°m th·ªùi th√™m 12px ƒë·ªÉ c·ª©u ng∆∞·ªùi ch∆°i
    if (state.energy < 25) mg += 12;
    CONFIG.GAME.minGapObPx = clamp(mg, MIN_GAP_BASE - 24, MIN_GAP_BASE + 18);
  }


  /* ====== Auto tune perf by FPS/Stage ====== */
  function applyTier(tierName){
    const t = TIERS[tierName];
    CONFIG.PERF.maxEntities = t.maxEntities;
    CONFIG.PERF.maxParticles = t.maxParticles;
    CONFIG.GAME.maxSpawnsPerFrame = t.cap;
    ROAD_STEP = t.roadStep;
    rebuildSpawnTable(t.minSpawnEvery);

    const newDpr = clamp(DPR + t.dprAdj, CONFIG.PERF.minDpr, CONFIG.PERF.dprMax);
    if (Math.abs(newDpr - DPR) > 0.01){
      DPR = newDpr; fitCanvas(canvas);
    }
  }
  function autoTune(){
    if (now() - state._tierLockT < 1500) return;
    let target = 0;
    if (state.fpsEMA < 48 || state.stage >= 10) target = 1;
    if (state.fpsEMA < 42 || state.stage >= 12) target = 2;
    if (target !== state.gfxTier){
      state.gfxTier = target;
      applyTier(target===2 ? 'low' : target===1 ? 'mid' : 'base');
      state._tierLockT = now();
    }
  }
  function applyStageSpeed(dt) {
    // speed t·ªëi thi·ªÉu theo stage: base * (1 + perStage*(stage-1))
    const targetMin = CONFIG.GAME.baseSpeed * (1 + (state.stage - 1) * SPEED_STAGE.perStage);
    // ti·∫øn d·∫ßn v·ªÅ targetMin khi speed ƒëang th·∫•p h∆°n (lerp c√≥ gia t·ªëc nh·∫π)
    if (state.speed < targetMin) {
      const k = Math.min(1, dt / 180);            // dt t√≠nh theo ms khung h√¨nh hi·ªáu d·ª•ng
      state.speed += (targetMin - state.speed) * (0.18 + 0.62 * k);
    }
    // tr·∫ßn t·ªëc ƒë·ªô tuy·ªát ƒë·ªëi
    state.speed = Math.min(state.speed, SPEED_STAGE.max);
  }

  /* =============== Update =============== */
  function update(dt) {
    const timeScale = state.holding && state.energy>0 ? CONFIG.GAME.freezeSlow : 1;
    const dtEff = dt * timeScale;

    if (state.grace>0) state.grace = Math.max(0, state.grace - dt);

    /* ===== Energy model (Freeze d·ªÖ ch·ªãu) ===== */
    let canFreeze = state.holding;
    
    // 0) N·∫øu ƒëang b·ªã ‚Äúkh√≥a‚Äù v√¨ c·∫°n, bu·ªôc ph·∫£i h·ªìi t·ªõi rearmPct m·ªõi cho gi·ªØ again
    if (state.freezeLocked) {
      if (state.energy >= FREEZE.rearmPct) state.freezeLocked = false;
      else canFreeze = false;
    }
    
    // 1) N·∫øu nƒÉng l∆∞·ª£ng th·∫•p h∆°n ng∆∞·ª°ng b·∫≠t, kh√¥ng cho gi·ªØ (tr√°nh v·ª´a b·∫•m ƒë√£ t·ª•t m·∫°nh)
    // Ch·ªâ ch·∫∑n ·ªü TH·ªúI ƒêI·ªÇM B·∫ÆT ƒê·∫¶U gi·ªØ (tr√°nh ‚Äúƒëang gi·ªØ r·ªìi‚Äù m√† b·ªã ng·∫Øt drain)
    const justStartedHold = state.holding && (now() - state.holdStartT < 220);
    if (state.holding && state.energy < FREEZE.minToStart && justStartedHold) {
      canFreeze = false;
      if (now() - state.freezeWarnT > FREEZE.warnCooldownMs) {
        toast(`NƒÉng l∆∞·ª£ng th·∫•p (<${FREEZE.minToStart}%). Th·∫£ ƒë·ªÉ h·ªìi.`);
        state.freezeWarnT = now();
      }
    }

    

    // 2) T√≠nh hao theo ramp (mi·ªÖn ph√≠ freeMs ƒë·∫ßu, r·ªìi ramp t·ªõi 100%)
    
    /* ---- Theo d√µi th·ªùi gian gi·ªØ li√™n t·ª•c ---- */
    if (state.holding) {
      state.freezeAccum = (state.freezeAccum || 0) + dt;   // dt = ms khung
    } else {
      state.freezeAccum = 0;                               // bu√¥ng tay => reset
    }
    const tHold = state.freezeAccum;                       // t·ªïng ms ƒë√£ gi·ªØ
    
    let drain = 0;
    if (canFreeze) {
      /* Ramp sau freeMs */
      const afterFree  = Math.max(0, tHold - FREEZE.freeMs);
      const k          = Math.min(1, afterFree / FREEZE.rampMs);
      const rampFactor = FREEZE.rampMin + (1 - FREEZE.rampMin) * k;
    
      drain = CONFIG.GAME.freezeRate * rampFactor * (dt / 10);
    
      /* Over-heat: gi·ªØ > 6 s ‚Üí hao +30 % */
      if (tHold > 6000) drain *= 1.3;
    }

    
      // ‚õî Gi·ªØ gi·ªØa 2 l√†n ‚Üí tƒÉng hao
      const frac = state.lane - Math.floor(state.lane);
      if (frac > ANTI_MID.bandL && frac < ANTI_MID.bandR) {
        drain *= ANTI_MID.drainMul;
      }
    
    // 3) H·ªìi t·ª± nhi√™n khi KH√îNG gi·ªØ
    const passive = (!state.holding && !state.energyZeroT)
      ? CONFIG.GAME.regenPassive * (dt / 10)
      : 0;
        
    // 4) C·∫≠p nh·∫≠t nƒÉng l∆∞·ª£ng
    state.energy = clamp(state.energy - drain + passive, 0, 100);
    drawEnergyBar();
    // === Low-energy beep (feedback c·∫£m x√∫c) ===
    if (!state._lowEnergyWarned && state.energy < 15){
      AudioKit.sfx('taunt'); state._lowEnergyWarned = true;
    }
    if (state._lowEnergyWarned && state.energy > 22){
      state._lowEnergyWarned = false;
    }
    // 5) N·∫øu v·ª´a c·∫°n trong l√∫c gi·ªØ ‚Üí kh√≥a Freeze cho t·ªõi khi h·ªìi ‚â• rearmPct
    if (canFreeze && state.energy <= 0) {
      state.freezeLocked = true;
      //state.holding = false;
      state.lastHoldEndT = now();
      if (now() - state.freezeWarnT > FREEZE.warnCooldownMs) {
        toast(`Ki·ªát s·ª©c! ƒê·ª£i h·ªìi ‚â•${FREEZE.rearmPct}% ƒë·ªÉ Freeze.`);
        state.freezeWarnT = now();
      }
    }
    
    /* ===== Death-by-Fatigue: h·∫øt nƒÉng l∆∞·ª£ng ‚Üí ƒë·∫øm ng∆∞·ª£c 10s ===== */
    /* ===== Death-by-Fatigue: h·∫øt nƒÉng l∆∞·ª£ng ‚Üí ƒë·∫øm ng∆∞·ª£c 10s ===== */
    if (ENERGY_DEATH.enable) {
    
      if (state.energy <= 0) {
        // b·∫Øt ƒë·∫ßu ho·∫∑c ti·∫øp t·ª•c countdown
        if (!state.energyZeroT) {
          state.energyZeroT      = now();
          state.energyCntRemain  = ENERGY_DEATH.windowMs; // ms
          state._secLeft         = undefined;             // force c·∫≠p nh·∫≠t ngay
          showCountdown(Math.ceil(state.energyCntRemain / 1000));
          toast(`H·∫øt nƒÉng l∆∞·ª£ng! ${ENERGY_DEATH.windowMs/1000}s ƒë·ªÉ h·ªìi ‚â•${ENERGY_DEATH.revivePct}%`);
          if (DBG) console.debug('[fatigue] start 10s window');
        } else {
          state.energyCntRemain = Math.max(0, state.energyCntRemain - dt);
        }
    
        // c·∫≠p nh·∫≠t HUD m·ªói khi s·ªë gi√¢y ƒë·ªïi
        const secLeft = Math.ceil(state.energyCntRemain / 1000);
        if (secLeft !== state._secLeft) {
          state._secLeft = secLeft;
          showCountdown(secLeft);      // üëà lu√¥n d√πng helper ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã
          AudioKit.sfx('taunt');
        }
    
        // k·ªãp h·ªìi v∆∞·ª£t ng∆∞·ª°ng ‚Üí hu·ª∑ countdown
        if (state.energy >= ENERGY_DEATH.revivePct) {
          state.energyZeroT = 0;
          state.energyCntRemain = 0;
          state._secLeft = undefined;
          hideCountdown();
          if (DBG) console.debug('[fatigue] recovered >= revivePct ‚Üí cancel');
        }
        // h·∫øt gi·ªù m√† v·∫´n ch∆∞a h·ªìi ƒë·ªß ‚Üí thua v√¨ ki·ªát s·ª©c
        else if (state.energyCntRemain <= 0) {
          state.deathReason = 'fatigue';
          hideCountdown();
          if (DBG) console.debug('[fatigue] timeout ‚Üí gameOver');
          return gameOver();
        }
    
      } else {
        // ƒëang >0% nƒÉng l∆∞·ª£ng: n·∫øu t·ª´ng v√†o countdown th√¨ x√©t ƒëi·ªÅu ki·ªán hu·ª∑
        if (state.energyZeroT && state.energy >= ENERGY_DEATH.revivePct) {
          state.energyZeroT = 0;
          state.energyCntRemain = 0;
          state._secLeft = undefined;
          hideCountdown();
          if (DBG) console.debug('[fatigue] cleared while >0% and >= revivePct');
        }
      }
    }




    state.speed += CONFIG.GAME.accel * dtEff/16.6;
    state.spawnIdx += dtEff/16.6;
    const spawnEveryBase = SPAWN_TABLE[Math.min(SPAWN_TABLE.length-1, state.spawnIdx|0)];
    const spawnEvery = spawnEveryBase * state.dirMul;
    state.score += dtEff * 0.06 * scoreMultiplier();
    $('#multLabel').textContent = 'x' + scoreMultiplier().toFixed(1);
    $('#score').textContent = String(Math.floor(state.score));

    smoothLane(dtEff);
    /* ===== Auto-snap v·ªÅ gi·ªØa l√†n (khi bu√¥ng tay) ===== */
    const idleTooLong = state.dragging && (now() - state.lastDragT > 300);
    if (AUTO_SNAP.enable && !state.holding && (!state.dragging || idleTooLong)) {
      const nearest = Math.round(state.desiredLane);     // l√†n chu·∫©n (0,1,2‚Ä¶)
      const diff    = nearest - state.desiredLane;
      if (Math.abs(diff) > 0.001) {                      // c√≤n l·ªách
        state.desiredLane += diff * AUTO_SNAP.speed;     // n·ªôi suy √™m
        if (Math.abs(nearest - state.desiredLane) <= 0.02){
          state.desiredLane = nearest;                   // ch·ªët c·ª©ng
          state.laneV = 0;                               // d·ª´ng dao ƒë·ªông
        }
      }
    }

    /* Theo d√µi ƒë·ªïi l√†n nguy√™n ƒë·ªÉ reset ƒë·ªìng h·ªì camping */
    {
      const li = Math.round(state.desiredLane);
      if (li !== state._laneI) {
        state._laneI = li;
        state.lastLaneChangeT = now();
      }
    }

    applyStages();
    applyStageSpeed(dtEff);
    // === Dynamic Director ===
    const TARGET = 0.55;
    const t = computeTension();
    const err = t - TARGET;
    state.dirMul = clamp(1 + err*0.6, 0.8, 1.25);  // >1 cƒÉng ‚Üí th∆∞a h∆°n
    
    // N·ªõi khe khi qu√° cƒÉng; thu khe khi qu√° d·ªÖ (nh·∫π tay)
    const baseGap = MIN_GAP_BASE;                   // ƒë√£ l∆∞u ·ªü code c·ªßa anh
    const adj = (err>0 ? 10*err : -6*Math.abs(err));
    CONFIG.GAME.minGapObPx = clamp(baseGap + adj, baseGap - 18, baseGap + 18);
    
    // C·∫£nh b√°o ‚Äúc·ª≠a h·∫πp‚Äù s·∫Øp t·ªõi
    if (!state._surgeWarned && (state.nextSurge - state.score) <= 60) {
      toast('S·∫Øp c·ª≠a h·∫πp!'); state._surgeWarned = true;
    }
    if (state.surgeMs === 0 && state.score < state.nextSurge - 60) state._surgeWarned = false;

    if (state.score >= state.nextSurge){ state.surgeMs = CONFIG.GAME.surgeMs; state.nextSurge += CONFIG.GAME.surgeEvery; toast('C·ª≠a h·∫πp 3s!'); AudioKit.sfx('taunt'); }
    if (state.surgeMs>0) state.surgeMs = Math.max(0, state.surgeMs - dt);

    state.lastSpawn += dtEff;
    const spawnMul = state.surgeMs>0 ? 0.7 : 1;
    let spawned=0;
    const cap = Math.min(CONFIG.GAME.maxSpawnsPerFrame, CONFIG.PERF.maxEntities - state.entities.length);
    while (state.lastSpawn >= spawnEvery * spawnMul && spawned < cap) {
      state.lastSpawn -= spawnEvery * spawnMul;
      const times = 1 + (state.surgeMs>0 ? 1 : 0);
      for (let k=0;k<times;k++) trySpawn();
      spawned++;
    }
    if (spawned >= cap && state.lastSpawn > spawnEvery * spawnMul * 4) state.lastSpawn = 0;

    const px = laneX(state.lane), py = state.playerY;
    let eLnear = null, eRnear = null; // ƒë·ªÉ v·∫Ω link / bonus

    for (let i=state.entities.length-1;i>=0;i--) {
      const e = state.entities[i]; e.y += state.speed * dtEff/1000;
      const ex = laneX(e.lane), ey = e.y;

      if (e.type === 'orb') {
        const hitOrb = aabb(px, py, HIT.P_W, HIT.P_H, ex, ey, 22, 22);
        if (hitOrb) {
          state.score += 50; state.energy = Math.min(100, state.energy + CONFIG.GAME.regenOrb);
          state.entities.splice(i,1); flash(120); spawnParticles(px,py,'#38bdf8',12,1.1); AudioKit.sfx('orb'); vibrate(12);
          continue;
        }
      }

      if (e.type === 'ob') {
        const collided = (state.grace<=0) && aabb(px,py,HIT.P_W,HIT.P_H, ex,ey,HIT.OB_W,HIT.OB_H);
        const near = !collided && aabb(px,py,HIT.P_W+HIT.NEAR_PAD,HIT.P_H+HIT.NEAR_PAD, ex,ey,HIT.OB_W+HIT.NEAR_PAD,HIT.OB_H+HIT.NEAR_PAD);

        if (near && !e.nearDone) {
          const cd = state.holding ? ANTI_MID.nearCooldownMs : 240;
          if (now() - state.lastNearT > cd) {
            // combo
            if (now() - state.comboT < 1200) state.combo++; else state.combo = 1;
            state.comboT = now();
        
            // h·ªìi nƒÉng l∆∞·ª£ng: ƒëang gi·ªØ th√¨ ph·∫°t n·∫∑ng
            const base = CONFIG.GAME.regenNear + Math.min(12, 2 * Math.max(0, state.combo - 1));
            const bonus = state.holding ? Math.max(1, Math.floor(base * ANTI_MID.nearPenalty)) : base;
        
            state.energy = Math.min(100, state.energy + bonus);
            state.score  += 4 * state.combo;
        
            toast(state.combo > 1 ? `NEAR-MISS x${state.combo} +${bonus}%` : `NEAR-MISS +${bonus}%`);
            state.lastNearT = now();
            AudioKit.sfx('near');
            vibrate(10);
        
            e.nearDone = true;
          }
        }
        

        if (collided) {
          if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
          boom(); spawnParticles(px,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
          return gameOver();
        }

        // Ghi nh·∫≠n hai kh·ªëi ·ªü 2 l√†n k·ªÅ nhau quanh ng∆∞·ªùi ch∆°i ƒë·ªÉ x·ª≠ l√Ω link/bonus
        const L = Math.floor(state.lane), R = L+1;
        if (e.lane===L && Math.abs(ey - py) < 34) eLnear = e;
        if (e.lane===R && Math.abs(ey - py) < 34) eRnear = e;
      }

      if (e.y - py > HIT.OB_H) e.nearDone = false;
      if (e.y > H+50) state.entities.splice(i,1);
    }

    /* ===== C√¥ng b·∫±ng ‚Äúƒëi gi·ªØa 2 c·ªôt‚Äù: ch·ªâ x·ª≠ thua n·∫øu khe th·∫≠t s·ª± KH√îNG L·ªåT ===== */
    if (state.grace <= 0) {
      const frac = state.lane - Math.floor(state.lane);
      if (frac > 0.44 && frac < 0.56) {
        const L = Math.floor(state.lane), R = L + 1;
        if (eLnear && eRnear) {
          const laneW = laneWidth();
          const gapBetweenInnerEdges = laneW - 2*(HIT.OB_W/2); // = laneW - 36
          const needToPass = HIT.P_W + 6; // ng∆∞·ªùi ch∆°i + bi√™n an to√†n
          const impossible = gapBetweenInnerEdges < needToPass;

          // hi·ªÉn th·ªã ch·∫•m ƒë·ªè gi·ªØa 2 kh·ªëi (ƒë·∫≠m n·∫øu impossible)
          addLink(py, impossible);

          if (impossible) {
            if (state.score > state.best){ state.best = Math.floor(state.score); localStorage.setItem('hrfz_best', state.best); }
            const pxMid = laneX(state.lane); boom(); spawnParticles(pxMid,py,'#e11d48',22,1.6); AudioKit.sfx('hit'); vibrate([50,40,80]);
            return gameOver();
          } else {
            // th∆∞·ªüng SLIP nh·ªè khi l·ªçt khe h·∫πp (cooldown)
            if (now() - state.lastSlipT > 800) {
              state.lastSlipT = now();
              state.score += 12;
              if (!state.holding || ANTI_MID.slipGiveEnergyWhenFreeze) {
                state.energy = Math.min(100, state.energy + 4);
              }
              toast('SLIP +12');
              if (!state.holding) AudioKit.sfx('near');
            }
          }
        }
      }
    }

    // Particles
    const pf = state.lowSpec ? 0.7 : 1;
    for (let i=state.particles.length-1;i>=0;i--){
      const p=state.particles[i]; p.age += dtEff; if (p.age>p.life){ state.particles.splice(i,1); continue; }
      p.x += p.vx * dtEff/16.6; p.y += p.vy * dtEff/16.6; p.vy += 0.002*dtEff*pf;
    }
    // links age
    for (let i=links.length-1;i>=0;i--){ links[i].age += dtEff; if (links[i].age>links[i].life) links.splice(i,1); }

    state.shake *= mqlReduce.matches ? 0.9 : 0.92;
  }
  /* G·ª£i √Ω l√†n ƒë·ªÉ ph√° "h√†nh lang" (2 k√≠n, 1 tr·ªëng trong c√πng d·∫£i y) */
  /* G·ª£i √Ω l√†n ƒë·ªÉ ph√° "h√†nh lang" (2 k√≠n, 1 tr·ªëng trong d·∫£i y g·∫ßn nhau) */
  /* ---------- B·∫ª ‚Äúh√†nh lang an to√†n‚Äù ---------- */
  function corridorSuggest(y){
    // qu√©t d·∫£i ¬±band quanh y
    const band = CONFIG.GAME.minGapObPx + ROAD_STEP;  // r·ªông h∆°n ‚Üí b·∫Øt ƒë·ªß 2 c·ªôt
    const occ  = new Array(CONFIG.GAME.lanes).fill(false);

    for (const e of state.entities){
      if (e.type !== 'ob') continue;
      if (Math.abs(e.y - y) <= band) occ[e.lane] = true;
    }
    let empty = -1, filled = 0;
    for (let i = 0; i < occ.length; i++){
      if (occ[i]) filled++; else empty = i;
    }
    return (filled === CONFIG.GAME.lanes - 1) ? empty : -1;
  }



  /* ====== Spawn kh·ªëi ====== */
  function trySpawn(){
    if (state.entities.length >= CONFIG.PERF.maxEntities) return;

    // 60s ƒë·∫ßu (+ ƒë·∫øn khi ƒë·∫°t 200 ƒëi·ªÉm): h·∫ßu nh∆∞ to√†n Orb ƒë·ªÉ l√†m quen
    const early = ((now() - state.startedAt) < 20000) || (state.score < 100);
    const type  = (state.rng() < (early ? 0.60 : CONFIG.GAME.orbChance)) ? 'orb' : 'ob';
    if (early && type === 'ob') return; // m·ªü ƒë·∫ßu: h·∫°n ch·∫ø obstacle


    let lane  = Math.floor(state.rng() * CONFIG.GAME.lanes);
    let tries = 0;

    /* 1. Anti-camping */
    if (type === 'ob'
        && now() - state.lastLaneChangeT > ANTI.campMs
        && now() - state._antiCampT      > ANTI.campCooldownMs){
      lane = Math.round(state.lane);               // ch·∫∑n ngay l√†n hi·ªán t·∫°i
      state._antiCampT = now();
      if (DBG) toast('ANTI-CAMP');
    }

    /* 2 + 3. Jitter Y & Corridor fix */
    do {
      // Jitter 2 chi·ªÅu ¬±spawnJitter
      const jitter = (state.rng() * 2 - 1) * ANTI.spawnJitter;
      const y0 = -40 + jitter;                     // üëà ƒë·ªïi d·∫•u ¬±

      if (okGapForLane(lane, type, y0) &&
          (type !== 'ob' || !rowBlocked(y0))){       // ‚ú® NEW ch·ªët an to√†n
        state.entities.push({type, lane, y:y0, nearDone:false});
        return;
      }

      lane = (lane + 1) % CONFIG.GAME.lanes;       // th·ª≠ l√†n kh√°c
    } while (++tries < CONFIG.GAME.maxSpawnAttempts);
  }
  function computeTension(){
    // 0..1: 0 = r·∫•t th∆∞ th√°i, 1 = c·ª±c cƒÉng
    const e = 1 - clamp(state.energy/100, 0, 1);                      // √≠t nƒÉng l∆∞·ª£ng ‚Üí cƒÉng
    const nm = Math.max(0, 1 - (now() - (state.lastNearT||0))/1200);   // v·ª´a near-miss ‚Üí cƒÉng
    const sp = clamp((state.speed - CONFIG.GAME.baseSpeed) / (CONFIG.GAME.baseSpeed*1.8 - CONFIG.GAME.baseSpeed), 0, 1);
    return clamp(0.5*e + 0.35*nm + 0.15*sp, 0, 1);
  }


  /* =============== Render =============== */
  function laneX(lane){
    const roadW=W - MARGIN*2; const laneW = roadW/CONFIG.GAME.lanes;
    return Math.round(MARGIN + laneW*(0.5 + lane));
  }

  const GRAD={};
  function ensureGradients(){
    if (!GRAD.player){
      GRAD.player = ctx.createLinearGradient(-16,-16,16,16);
      GRAD.player.addColorStop(0,'#22d3ee'); GRAD.player.addColorStop(1,'#0ea5e9');
      GRAD.ob = ctx.createLinearGradient(0,-18,0,18);
      GRAD.ob.addColorStop(0,'#c64040'); GRAD.ob.addColorStop(1,'#9f2c2c');
    }
  }

  function drawRoad() {
    // N·ªÅn ch√≠nh
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#09111b'); g.addColorStop(0.55, '#0a1320'); g.addColorStop(1, '#0b1220');
    ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

    // V·∫°ch ph√¢n l√†n d·ªçc
    const lanes = CONFIG.GAME.lanes, roadW = W - MARGIN * 2;
    ctx.save();
    ctx.strokeStyle = 'rgba(148,163,184,0.10)'; ctx.lineWidth = 2;
    for (let i = 1; i < lanes; i++) {
      const x = MARGIN + (roadW / lanes) * i;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    ctx.restore();

    // Vignette & spotlight
    const spot = ctx.createRadialGradient(W/2, H*0.16, 20, W/2, H*0.16, H*0.92);
    spot.addColorStop(0, 'rgba(56,189,248,0.18)');
    spot.addColorStop(1, 'rgba(56,189,248,0.00)');
    ctx.fillStyle = spot; ctx.fillRect(0, 0, W, H);

    if (THEME_PRO) {
      // T·ªëi nh·∫π hai m√©p ƒë∆∞·ªùng (t·∫°o chi·ªÅu s√¢u)
      const edgeL = ctx.createLinearGradient(0, 0, MARGIN+12, 0);
      edgeL.addColorStop(0, 'rgba(0,0,0,0.35)'); edgeL.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = edgeL; ctx.fillRect(0, 0, MARGIN+12, H);

      const edgeR = ctx.createLinearGradient(W-(MARGIN+12), 0, W, 0);
      edgeR.addColorStop(0, 'rgba(0,0,0,0)'); edgeR.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = edgeR; ctx.fillRect(W-(MARGIN+12), 0, MARGIN+12, H);

      // V·ªát ‚Äúspeed glow‚Äù r·∫•t m·ªù theo stage (kh√¥ng k·∫ª v·∫°ch ngang)
      const k = Math.min(1, state.stage / 10);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.05 + 0.08 * k;
      const w = (W - MARGIN*2) * 0.9;
      ctx.beginPath();
      ctx.ellipse(W/2, H*0.55, w/2, H*0.75, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(56,189,248,0.35)';
      ctx.fill();
      ctx.restore();
    }
  }


  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }
  function drawPlayer(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(0,18,20,8,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.player; roundRect(-16,-16,32,32,8,true,false);
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(0,-8); ctx.lineTo(8,0); ctx.lineTo(0,8); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
  function drawObstacle(x,y){
    ctx.save(); ctx.translate(x,y);
    if (!mqlReduce.matches){ ctx.fillStyle='rgba(0,0,0,.28)'; ctx.beginPath(); ctx.ellipse(0,16,16,6,0,0,Math.PI*2); ctx.fill(); }
    ensureGradients();
    ctx.fillStyle=GRAD.ob; roundRect(-18,-18,36,36,8,true,false);
    ctx.strokeStyle='rgba(0,0,0,.40)'; ctx.lineWidth=1.5; roundRect(-18,-18,36,36,8,false,true);
    ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-14,-12); ctx.lineTo(14,-12); ctx.stroke();
    ctx.restore();
  }
  function drawOrb(x,y){
    ctx.save(); ctx.translate(x,y);
    const r=10+Math.sin(performance.now()/120 + x)*2;
    const g=ctx.createRadialGradient(0,0,2,0,0,r);
    g.addColorStop(0,'rgba(255,255,255,0.85)');
    g.addColorStop(1,'rgba(56,189,248,0.9)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  /* ===== V·∫Ω ch·∫•m ƒë·ªè n·ªëi gi·ªØa 2 kh·ªëi ===== */
  function drawLinks(){
    const lw = HIT.OB_W/2, xStep = 14;
    for (const L of links){
      const lifeK = Math.max(0, 1 - L.age/L.life);
      const alpha = (L.strong ? 0.55 : 0.28) * lifeK;
      const Llane = Math.floor(state.lane); // v·ªã tr√≠ lane hi·ªán t·∫°i ch·ªâ ƒë·ªÉ l·∫•y x
      const x1 = laneX(0) + (laneWidth()*Math.floor(state.lane)); // kh√¥ng d√πng lane hi·ªán t·∫°i; ta d·ª±ng chung cho m·ªçi c·∫∑p
      // v·∫Ω cho m·ªçi c·∫∑p k·ªÅ nhau
      for (let k=0; k<CONFIG.GAME.lanes-1; k++){
        const xa = laneX(k) + lw, xb = laneX(k+1) - lw;
        ctx.globalAlpha = alpha;
        for (let x=xa; x<=xb; x+=xStep){
          ctx.fillStyle = L.strong ? 'rgba(239,68,68,1)' : 'rgba(239,68,68,1)';
          ctx.beginPath(); ctx.arc(x, L.y, 2.2, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    }
  }

  /* =============== FX / Gauge / Toast =============== */
  let flashT=0, boomT=0;
  function flash(ms){ if (!mqlReduce.matches){ flashT=now()+ms; } }
  function boom(){ boomT=now()+250; state.shake = mqlReduce.matches ? 0 : 10; }
  const origFill = ctx.fillStyle;
  const _draw = draw; draw = function(){ _draw(); postFX(); };
  function postFX(){
    const t=now();
    if (flashT>t){ ctx.fillStyle='rgba(255,255,255,.2)'; ctx.fillRect(0,0,W,H); ctx.fillStyle=origFill; }
    if (boomT>t){ const k=(boomT-t)/250; ctx.save(); ctx.translate(W/2,H/2); ctx.rotate((1-k)*0.4); ctx.scale(1+(1-k)*0.05,1+(1-k)*0.05); ctx.restore(); }
  }

  let lastGaugePct=-1;
  function drawGauge(){ /* disabled: ch·ªâ d√πng energy bar */ }

  function drawEnergyBar(){
    const pct = clamp(state.energy,0,100);
    energyFill.style.width = pct + '%';

    /* ƒê·ªïi m√†u t·ª´ xanh‚Üív√†ng‚Üíƒë·ªè */
    if (pct > 60)      energyFill.style.background = 'linear-gradient(90deg,#16a34a,#22d3ee)';
    else if (pct > 30) energyFill.style.background = 'linear-gradient(90deg,#eab308,#facc15)';
    else               energyFill.style.background = 'linear-gradient(90deg,#ef4444,#b91c1c)';
  }

  function toast(txt){
    const el=$('#toast'); el.textContent=txt; el.classList.add('show');
    clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'),760);
  }

  /* =============== UI & Poster =============== */
  function gameOver(){
    state.running=false; state.over=true;
    state.playMs += (now()-state.startedAt);
    $('#uiHUD').hidden=true; $('#uiOver').hidden=false; $('#touchCtrl').hidden=true;
    $('#finalScore').textContent = Math.floor(state.score);
    $('#best2').textContent = state.best;
    const s=Math.floor(state.score), next=Math.ceil(s/100)*100, diff=next-s;
    $('#overMsg').textContent = (s>0 && diff>0 && diff<=12) ? `Thi·∫øu ${diff} ƒëi·ªÉm n·ªØa l√† ch·∫°m ${next}!`
      : (s>state.best ? 'K·ª∑ l·ª•c m·ªõi! L·∫ßn sau v∆∞·ª£t 2.500 nh√©.' : 'G·∫ßn th√¥i, th√™m ch√∫t ‚Äús∆∞·ª£t nh·∫π‚Äù l√† qua!');
    if (state.deathReason === 'fatigue') {
      $('#overMsg').textContent = `Ki·ªát s·ª©c: H·∫øt ${ENERGY_DEATH.windowMs/1000}s m√† kh√¥ng h·ªìi ‚â•${ENERGY_DEATH.revivePct}% nƒÉng l∆∞·ª£ng.`;
    }
    state.deathReason = '';

    const payload={ deviceId:getDeviceId(), name:String(state.name||'').slice(0,16),
      score:Math.max(0,Math.floor(state.score)), tz:Intl.DateTimeFormat().resolvedOptions().timeZone||'UTC',
      ua:navigator.userAgent, seed:dailySeed(), playMs:Math.floor(state.playMs), near:state.nearMissCount,
      clientProof: crypto.subtle ? 'sha256' : '' };
    try{
      if (crypto && crypto.subtle){
        const enc=new TextEncoder().encode(payload.deviceId+'|'+payload.score+'|'+payload.seed+'|'+payload.playMs+'|'+payload.near);
        crypto.subtle.digest('SHA-256', enc).then(buf=>{
          payload.clientProof=Array.from(new Uint8Array(buf)).map(x=>x.toString(16).padStart(2,'0')).join('');
          postScore(payload);
        }).catch(()=>postScore(payload));
      } else postScore(payload);
    }catch(_){ postScore(payload); }
  }

  function resetGame(){
    state.running=true; state.over=false; state.startedAt=now(); state.playMs=0;
    state.score=0; state.speed=CONFIG.GAME.baseSpeed;
    state.lastSpawn=0; state.spawnIdx=0;
    state.lane=1.0; state.desiredLane=1.0; state.laneV=0;
    state.entities.length=0; state.particles.length=0; links.length=0;
    state.energy=60; state.shake=0; state.surgeMs=0; state.nextSurge=CONFIG.GAME.surgeEvery;
    state.combo=0; state.comboT=0; state.nearMissCount=0;
    state.energyZeroT = 0;
    state.energyCntRemain = 0;
    state._secLeft = undefined;
    state.deathReason = '';
    hideCountdown();

    state.grace=CONFIG.GAME.graceMs; state.stage=1; state.lastSlipT=0; $('#stageLabel').textContent='Stage 1';
    $('#playerName').hidden = !state.name;
    $('#playerName').textContent = state.name || '';
    $('#uiHUD').hidden=false; $('#uiStart').hidden=true; $('#uiOver').hidden=true; $('#touchCtrl').hidden=false;
    $('#score').textContent='0'; $('#best').textContent=String(state.best);
    lastGaugePct=-1; drawGauge();
    drawEnergyBar();
  }
  function startFromUI(){
    const name = $('#name').value.trim().slice(0,16);
    state.name  = name;
    if (name) localStorage.setItem('hrfz_last_name', name);  
    /* NEW: hi·ªÉn th·ªã pill t√™n */
    $('#playerName').textContent = name || 'Kh√¥ng T√™n';
    $('#playerName').hidden      = !name;

    resetGame();
    $('#playerName').hidden = !state.name;
    $('#playerName').textContent = state.name || '';
    loop();
    if ($('#optBgm').checked) AudioKit.startBgm(); else AudioKit.stopBgm();
  }


  $('#btnPlay').addEventListener('click', startFromUI);
  $('#btnRetry').addEventListener('click', startFromUI);
  $('#btnShare').addEventListener('click', async ()=>{
    const text=`T√¥i ƒë·∫°t ${Math.floor(state.score)} ƒëi·ªÉm ·ªü #HyperRushFreeze ‚Äî b·∫°n d√°m v∆∞·ª£t kh√¥ng?`;
    try{
      if (navigator.share) await navigator.share({title:'HyperRush Freeze', text, url:location.href});
      else { await navigator.clipboard.writeText(`${text}\n${location.href}`); alert('ƒê√£ copy li√™n k·∫øt!'); }
    }catch(_){}
  });
  $('#btnPoster').addEventListener('click', ()=>makePoster(true));
  $('#btnSave').addEventListener('click', ()=>makePoster(false));
  $('#btnL').addEventListener('click', ()=>stepLane(-1));
  $('#btnR').addEventListener('click', ()=>stepLane(1));
  $('#best').textContent = String(state.best);

  const lastName=localStorage.getItem('hrfz_last_name'); if (lastName) $('#name').value=lastName;

  // ui.js ‚Äì s·ª± ki·ªán n√∫t ‚ÄúTop 10‚Äù


  document.getElementById('btnTop').onclick = () => TopSheet.open();


  $('#btnTut').addEventListener('click', ()=>$('#tut').hidden=false);
  $('#btnOkTut').addEventListener('click', ()=>{ $('#tut').hidden=true; localStorage.setItem('hrfz_seen_tut','1'); });

  if (!localStorage.getItem('hrfz_seen_tut')) $('#tut').hidden=false;

  const ps = new URLSearchParams(location.search);
  if (ps.get('autoplay')==='1'){ setTimeout(startFromUI, 300); }

  if ('serviceWorker' in navigator) { addEventListener('load', ()=>navigator.serviceWorker.register('./sw.js').catch(()=>{})); }
  new ResizeObserver(()=>fitCanvas(canvas)).observe($('#wrap'));

  // Pause/Resume
  let last=now(), acc=0;
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden){
      state.holding=false; state._autoResume=state.running; state.running=false;
    } else if (state._autoResume){
      state.running=true; state._autoResume=false; last=now(); loop();
    }
  }, {passive:true});
  function drawWatermark(){
    const t = (META.author ? META.author : '') + (META.version ? ' ‚Ä¢ ' + META.version : '');
    if (!t) return;
    ctx.save();
    ctx.globalAlpha = .65;
    ctx.fillStyle = '#93a4c3';
    ctx.font = '12px system-ui,Segoe UI,Roboto,Arial';
    ctx.textBaseline = 'bottom';
    ctx.fillText(t, 8, H - 8);
    ctx.restore();
  }

  /* =============== Main Loop (adaptive FPS & DPR + tier) =============== */
  function draw(){
    const lite = (state.gfxTier===2) && ((state.frame++ & 1)===1);
    ctx.clearRect(0,0,W,H);
    ctx.save();
    if (state.shake>0 && !mqlReduce.matches){
      ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
    }

    if (!lite) drawRoad();

    // 1) Entities tr∆∞·ªõc
    for (const e of state.entities)
      (e.type==='ob') ? drawObstacle(laneX(e.lane), e.y) : drawOrb(laneX(e.lane), e.y);

    // 2) ‚ú® Links sau ƒë·ªÉ lu√¥n n·∫±m tr√™n c√°c kh·ªëi
    drawLinks();

    // 3) Player + particles
    drawPlayer(laneX(state.lane), state.playerY);

    if (state.gfxTier===2){
      for (let i=0;i<state.particles.length;i+=2){
        const p=state.particles[i]; const k=1-(p.age/p.life); if (k<=0) continue;
        ctx.globalAlpha=Math.max(0,k); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    } else {
      for (const p of state.particles){
        const k=1-(p.age/p.life); ctx.globalAlpha=Math.max(0,k);
        ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+k*2,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    ctx.restore();
    drawGauge();

    drawWatermark(); 
  }


  function loop(){
    if (!state.running) return;
    const t=now(); let dt=Math.min(34,t-last); last=t; acc+=dt;

    const fps = 1000/Math.max(1, dt);
    state.fpsEMA = state.fpsEMA*0.9 + fps*0.1;

    if (state.fpsEMA < 52) state.lowSpec = true;
    autoTune();

    while (acc>=16){ update(16); acc-=16; }
    draw(); requestAnimationFrame(loop);
  }

  /* =============== Poster =============== */
  async function makePoster(onlyPreview){
    const off=document.createElement('canvas'); const s=720; off.width=s; off.height=1280;
    const c=off.getContext('2d');
    const g=c.createLinearGradient(0,0,0,1280); g.addColorStop(0,'#0a0f1c'); g.addColorStop(1,'#0b1220'); c.fillStyle=g; c.fillRect(0,0,off.width,off.height);
    c.fillStyle='#22d3ee'; c.font='700 44px system-ui,Segoe UI,Roboto'; c.fillText('HyperRush ‚Äî Freeze', 36, 80);
    c.fillStyle='#e5f0ff'; c.font='700 120px system-ui,Segoe UI,Roboto'; c.fillText(`${Math.floor(state.score)}`, 36, 220);
    c.fillStyle='#93a4c3'; c.font='400 28px system-ui,Segoe UI,Roboto';
    c.fillText(`Best ${state.best} ‚Ä¢ Stage ${state.stage} ‚Ä¢ Near-miss ${state.nearMissCount}`, 36, 260);
    c.drawImage(canvas, 0,0,canvas.width,canvas.height, 36, 300, 648, 1036);
    const blob=await new Promise(r=>off.toBlob(r,'image/png',0.92));
    const file=new File([blob],'hyperrush_poster.png',{type:'image/png'});
    if (onlyPreview){
      const url=URL.createObjectURL(blob); open(url,'_blank'); setTimeout(()=>URL.revokeObjectURL(url),60000);
    } else {
      if (navigator.canShare && navigator.canShare({files:[file]})){
        try{ await navigator.share({files:[file],title:'HyperRush Poster'}); return; }catch(_){}
      }
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hyperrush_poster.png'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),60000);
    }
  }

  $('#touchCtrl').hidden = !('ontouchstart' in window);
  $('#optBgm').addEventListener('change', e=>{ if(e.target.checked) AudioKit.startBgm(); else AudioKit.stopBgm(); }, {passive:true});

})();</script>

<script>
(function(){
  const API = (window.CONFIG && window.CONFIG.API_URL) || '';
  const S = { all:[], view:[], show:20, meName:'', meDevice:'', mounted:false };

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  function isVN(x){
    const tz = String(x.tz||'').toLowerCase(), name = String(x.name||'');
    return tz.includes('ho_chi_minh') || tz.includes('bangkok') || /üáªüá≥/u.test(name) || /\b(vn|viet|vietnam)\b/i.test(tz);
  }
  function guessMe(){
    const cand = document.querySelector('#name, input[name="name"], input[type="text"]');
    S.meName = (cand && cand.value || '').trim();
    S.meDevice = (window.state && window.state.deviceId) || '';   // üëà ƒë√∫ng tham chi·∫øu
  }

  const TopSheet = {
    async open(){
      guessMe();
      const root = document.getElementById('topSheet');
      if (!root){ console.warn('Missing #topSheet'); return; } // phanh an to√†n
      root.classList.add('show');
      if (!S.mounted){ this.mount(); S.mounted = true; }
      await this.refresh();
      this.applyFilters(true);
    },

    close(){ document.getElementById('topSheet').classList.remove('show'); },

    // ---- Robust refresh: JSON + JSONP fallback (kh√¥ng c·∫ßn CORS) ----
    async refresh(){
      if (!API){ S.all=[]; return; }
      try{
        const res  = await fetch(API + '?top=100&fillBots=1&fmt=json', { cache:'no-store', credentials:'omit', referrerPolicy:'no-referrer' });
        const json = await res.json();
        this.ingest(json);
      }catch(e){
        console.warn('TOP fetch error', e);
        await this.refreshJSONP();
      }
    },
    refreshJSONP(){
      return new Promise(resolve=>{
        const cb = 'top_cb_' + Math.random().toString(36).slice(2);
        window[cb] = (json)=>{ try{ delete window[cb]; }catch(_){ } s.remove(); this.ingest(json||{}); resolve(); };
        const s = document.createElement('script');
        s.src = API + '?' + new URLSearchParams({ top:'100', fillBots:'1', fmt:'js', cb });
        s.onerror = ()=>{ try{ delete window[cb]; }catch(_){ } s.remove(); resolve(); };
        document.head.appendChild(s);
      });
    },
    ingest(json){
      S.all = Array.isArray(json.items) ? json.items.map((it,i)=>({
        rk:i+1,
        name:String(it.name||'').trim() || 'Anonymous',
        score:Number(it.score)||0,
        tz:String(it.tz||''),
        ua:it.ua||'',
        deviceId:it.deviceId||''
      })) : [];
    },

    mount(){
      const search = document.getElementById('topSearch');
      const filter = document.getElementById('topFilter');
      const more   = document.getElementById('btnMore');
      search.addEventListener('input', ()=> this.applyFilters());
      filter.addEventListener('change', ()=> this.applyFilters(true));
      more.addEventListener('click', ()=> { S.show += 20; this.renderList(); });

      // k√©o xu·ªëng ƒë·ªÉ ƒë√≥ng
      const panel = document.querySelector('#topSheet .panel');
      let startY=0; panel.addEventListener('touchstart',e=>{ startY=e.touches[0].clientY; }, {passive:true});
      panel.addEventListener('touchmove',e=>{
        const dy = e.touches[0].clientY - startY;
        if (dy>60 && document.getElementById('topList').scrollTop<=0) this.close();
      }, {passive:true});

      // ESC ƒë√≥ng
      document.addEventListener('keydown', e=>{ if(e.key==='Escape') this.close(); }, {passive:true});

      // g·∫Øn n√∫t Top
      const btnTop = document.getElementById('btnTop');
      if (btnTop && !btnTop._bind){ btnTop._bind=1; btnTop.addEventListener('click', ()=>TopSheet.open()); }
    },

    applyFilters(resetShow){
      if (resetShow) S.show = 20;
      const q = document.getElementById('topSearch').value.trim().toLowerCase();
      const f = document.getElementById('topFilter').value;

      let arr = S.all.slice();
      if (q) arr = arr.filter(x => x.name.toLowerCase().includes(q) || (x.tz||'').toLowerCase().includes(q));
      if (f==='vn') arr = arr.filter(isVN);
      if (f==='around' && S.meName){
        const idx = arr.findIndex(x => x.name.toLowerCase()===S.meName.toLowerCase());
        if (idx>=0){ const from = Math.max(0, idx-10); arr = arr.slice(from, from+21); }
      }

      arr.sort((a,b)=> b.score-a.score).forEach((x,i)=> x.rk=i+1);
      S.view = arr;
      this.renderPodium();
      this.renderList();
    },

    renderPodium(){
      const wrap = document.getElementById('podium'); wrap.innerHTML='';
      const podium = S.view.slice(0,3);
      if (!podium.length){ wrap.innerHTML = '<div class="empty">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>'; return; }
      const medals = ['ü•à','ü•á','ü•â']; const order = [1,0,2];
      order.forEach((idx,i)=>{
        const x = podium[idx]; if (!x) { wrap.insertAdjacentHTML('beforeend','<div></div>'); return; }
        wrap.insertAdjacentHTML('beforeend', `
          <div class="card ${i===1?'r1':''}">
            <div class="rank">${medals[i]} H·∫°ng ${x.rk}</div>
            <div class="name">${escapeHtml(x.name)}</div>
            <div class="score">ƒêi·ªÉm: <b>${x.score}</b></div>
          </div>
        `);
      });
    },

    renderList(){
      const list = document.getElementById('topList'); list.innerHTML='';
      const limit = Math.min(S.show, S.view.length);
      for (let i=0;i<limit;i++){
        const x = S.view[i];
        const me = S.meName && x.name.toLowerCase()===S.meName.toLowerCase();
        list.insertAdjacentHTML('beforeend', `
          <div class="row ${me?'me':''}" aria-label="rank ${x.rk}">
            <div class="rk">${x.rk}</div>
            <div class="nm">${escapeHtml(x.name)}</div>
            <div class="sc">${x.score}</div>
          </div>
        `);
      }
      document.getElementById('btnMore').style.display = (limit < S.view.length) ? 'block' : 'none';
    }
  };

  window.TopSheet = TopSheet;
})();
</script>


</body>
</html>
